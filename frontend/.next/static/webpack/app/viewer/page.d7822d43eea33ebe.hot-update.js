"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/useAgentController.ts":
/*!*********************************************!*\
  !*** ./src/lib/agent/useAgentController.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgentController: function() { return /* binding */ useAgentController; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mockApi */ \"(app-pages-browser)/./src/lib/agent/mockApi.ts\");\n/* harmony import */ var _lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/audio/useAudioController */ \"(app-pages-browser)/./src/lib/audio/useAudioController.ts\");\n/* __next_internal_client_entry_do_not_use__ useAgentController auto */ \n\n\nfunction useAgentController(pdfRef, baseConfig, opts) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        status: \"idle\",\n        currentStepIndex: -1,\n        steps: []\n    });\n    const audio = (0,_lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__.useAudioController)();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const progressTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressPausedAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressPauseAccum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pendingNav = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [ttsActive, setTtsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ttsActiveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isAdvancingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsTextLenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsBoundarySeenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsBoundaryFallbackTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ttsStartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const estimatedTotalMsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const charRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsTextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const ttsWordStartsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const ttsTotalWordsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const userSkipRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const navigateTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (page)=>{\n        const go = async ()=>{\n            if (opts === null || opts === void 0 ? void 0 : opts.navigate) {\n                opts.navigate(page);\n            } else {\n                const api = pdfRef.current;\n                api === null || api === void 0 ? void 0 : api.goToPage(page);\n            }\n            await new Promise((r)=>setTimeout(r, 150));\n        };\n        const p = go().finally(()=>{\n            if (pendingNav.current === p) pendingNav.current = null;\n        });\n        pendingNav.current = p;\n        await p;\n    }, [\n        opts,\n        pdfRef\n    ]);\n    const stopProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressTimer.current) {\n            cancelAnimationFrame(progressTimer.current);\n            progressTimer.current = null;\n        }\n    }, []);\n    const tickProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const now = performance.now();\n        const paused = progressPausedAt.current;\n        const pauseAdj = progressPauseAccum.current + (paused ? now - paused : 0);\n        const elapsed = now - progressStart.current - pauseAdj;\n        let pct = Math.min(1, elapsed / Math.max(1, progressDuration.current));\n        if (ttsActiveRef.current && pct >= 1) pct = 0.98;\n        setProgress(pct);\n        if (pct < 1 || ttsActiveRef.current) {\n            progressTimer.current = requestAnimationFrame(tickProgress);\n        } else {\n            progressTimer.current = null;\n        }\n    }, []);\n    const startProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((durationMs)=>{\n        stopProgress();\n        setProgress(0);\n        progressDuration.current = Math.max(1000, durationMs);\n        progressStart.current = performance.now();\n        progressPausedAt.current = null;\n        progressPauseAccum.current = 0;\n        progressTimer.current = requestAnimationFrame(tickProgress);\n    }, [\n        stopProgress,\n        tickProgress\n    ]);\n    const cancelSpeech = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const speakText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text, fallbackMs)=>{\n        // Clear any prior boundary fallback timer\n        if (ttsBoundaryFallbackTimerRef.current) {\n            window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n            ttsBoundaryFallbackTimerRef.current = null;\n        }\n        ttsBoundarySeenRef.current = false;\n        var _text_length;\n        ttsTextLenRef.current = (_text_length = text === null || text === void 0 ? void 0 : text.length) !== null && _text_length !== void 0 ? _text_length : 0;\n        ttsTextRef.current = text || \"\";\n        // Precompute word starts for boundary-to-word mapping\n        ttsWordStartsRef.current = [];\n        ttsTotalWordsRef.current = 0;\n        if (text) {\n            const regex = /\\b\\w[\\w'\\-]*\\b/g;\n            let m;\n            while((m = regex.exec(text)) !== null){\n                if (typeof m.index === \"number\") {\n                    ttsWordStartsRef.current.push(m.index);\n                }\n            }\n            ttsTotalWordsRef.current = ttsWordStartsRef.current.length;\n        }\n        if (!text) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n        try {\n            const synth = window.speechSynthesis;\n            if (!synth) return ()=>{};\n            if (synth.speaking) synth.cancel();\n            const utter = new SpeechSynthesisUtterance(text);\n            // Keep a consistent rate for predictability\n            utter.rate = 1;\n            utter.onstart = ()=>{\n                setTtsActive(true);\n                ttsActiveRef.current = true;\n                // Clear user-initiated skip suppression once the new step starts speaking\n                userSkipRef.current = false;\n                ttsStartRef.current = performance.now();\n                charRateRef.current = 0;\n                estimatedTotalMsRef.current = fallbackMs || 5000;\n                // Always run a tick; if boundaries show up, it will adapt to time-based estimation\n                startProgress(estimatedTotalMsRef.current);\n            };\n            // Use boundary events to reflect real-time progress\n            utter.onboundary = (ev)=>{\n                ttsBoundarySeenRef.current = true;\n                // Stop timer fallback; boundary will drive progress\n                stopProgress();\n                const idx = typeof (ev === null || ev === void 0 ? void 0 : ev.charIndex) === \"number\" ? ev.charIndex : 0;\n                const starts = ttsWordStartsRef.current;\n                const totalWords = Math.max(1, ttsTotalWordsRef.current);\n                // Count words whose start index is <= current char index\n                let low = 0, high = starts.length;\n                while(low < high){\n                    const mid = low + high >> 1;\n                    if (starts[mid] <= idx) low = mid + 1;\n                    else high = mid;\n                }\n                const spokenWords = Math.min(low, totalWords);\n                let pctWords = spokenWords / totalWords;\n                if (ttsActiveRef.current && pctWords >= 1) pctWords = 0.98;\n                setProgress(pctWords);\n            };\n            utter.onend = ()=>{\n                setTtsActive(false);\n                ttsActiveRef.current = false;\n                // Complete progress and stop timer; auto-advance effect will pick this up\n                stopProgress();\n                setProgress(1);\n            };\n            synth.speak(utter);\n            // If boundary events arenâ€™t supported, start a fallback progress timer after a short delay\n            if (fallbackMs && fallbackMs > 0) {\n                ttsBoundaryFallbackTimerRef.current = window.setTimeout(()=>{\n                    if (!ttsBoundarySeenRef.current) {\n                        startProgress(fallbackMs);\n                    }\n                }, 700);\n            }\n            const cancel = ()=>{\n                try {\n                    synth.cancel();\n                } finally{\n                    setTtsActive(false);\n                    ttsActiveRef.current = false;\n                    if (ttsBoundaryFallbackTimerRef.current) {\n                        window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n                        ttsBoundaryFallbackTimerRef.current = null;\n                    }\n                }\n            };\n            return cancel;\n        } catch (e) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n    }, [\n        startProgress,\n        stopProgress\n    ]);\n    const playStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (step)=>{\n        var // Prefer TTS-driven progress via boundaries; fallback to a timer if boundaries arenâ€™t supported\n        _cancelSpeech_current;\n        // Ensure fresh progress/tts state for this step to avoid auto-advance races\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        setState((s)=>({\n                ...s,\n                status: \"navigating\"\n            }));\n        await navigateTo(step.page);\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        var _step_speakMs;\n        cancelSpeech.current = speakText(step.ttsText || step.transcript, (_step_speakMs = step.speakMs) !== null && _step_speakMs !== void 0 ? _step_speakMs : 5000);\n        // Optionally try audio as a subtle background beep if available\n        // but we no longer rely on audio end to advance\n        audio.play(step.audioUrl).catch(()=>{});\n    }, [\n        audio,\n        navigateTo,\n        speakText,\n        stopProgress\n    ]);\n    const start = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cfg)=>{\n        var _cancelSpeech_current;\n        // Clean up any prior run to ensure fresh state\n        try {\n            audio.stop();\n        } catch (e) {}\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        isAdvancingRef.current = false;\n        pendingNav.current = null;\n        setState((s)=>({\n                ...s,\n                status: \"fetching\",\n                error: undefined\n            }));\n        try {\n            const plan = await (0,_mockApi__WEBPACK_IMPORTED_MODULE_1__.fetchAgentPlan)({\n                ...baseConfig,\n                ...cfg\n            });\n            if (!plan.steps.length) throw new Error(\"No steps returned\");\n            // Initialize and let playStep handle navigation/progress; we only call it once here\n            setState({\n                status: \"navigating\",\n                currentStepIndex: 0,\n                steps: plan.steps\n            });\n            await playStep(plan.steps[0]);\n        } catch (e) {\n            setState((s)=>({\n                    ...s,\n                    status: \"error\",\n                    error: (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\"\n                }));\n        }\n    }, [\n        audio,\n        baseConfig,\n        playStep,\n        stopProgress\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.pause();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.speaking && !synth.paused) synth.pause();\n        } catch (e) {}\n        // Pause fallback timer progress if running\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current == null) {\n                progressPausedAt.current = performance.now();\n            }\n            if (progressTimer.current) {\n                cancelAnimationFrame(progressTimer.current);\n                progressTimer.current = null;\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"paused\"\n            }));\n    }, [\n        audio\n    ]);\n    const resume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.resume();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.paused) synth.resume();\n        } catch (e) {}\n        // Resume fallback timer progress if boundary not available\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current != null) {\n                progressPauseAccum.current += performance.now() - progressPausedAt.current;\n                progressPausedAt.current = null;\n            }\n            if (!progressTimer.current && progress < 1) {\n                progressTimer.current = requestAnimationFrame(tickProgress);\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n    }, [\n        audio,\n        progress,\n        tickProgress\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cancelSpeech_current;\n        audio.stop();\n        stopProgress();\n        setProgress(0);\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        setState({\n            status: \"stopped\",\n            currentStepIndex: -1,\n            steps: []\n        });\n    }, [\n        audio,\n        stopProgress\n    ]);\n    const skipTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        var _cancelSpeech_current;\n        const steps = state.steps;\n        if (index < 0 || index >= steps.length) return;\n        // Stop audio and speech and reset progress before switching\n        audio.stop();\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setState((s)=>({\n                ...s,\n                currentStepIndex: index\n            }));\n        await playStep(steps[index]);\n    }, [\n        audio,\n        playStep,\n        state.steps,\n        stopProgress\n    ]);\n    // Public user-initiated jump: prevent auto-advance from chaining over the userâ€™s selection\n    const jumpTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        userSkipRef.current = true;\n        await skipTo(index);\n    }, [\n        skipTo\n    ]);\n    // Auto-advance when progress completes AND TTS (if any) has ended.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (state.status !== \"playing\" || progress < 1 || ttsActive) return;\n        // If user just jumped, do not auto-advance from the old step completion\n        if (userSkipRef.current) return;\n        if (isAdvancingRef.current) return;\n        isAdvancingRef.current = true;\n        (async ()=>{\n            const next = state.currentStepIndex + 1;\n            if (next < state.steps.length) {\n                await skipTo(next);\n            } else {\n                // End of plan: behave like Stop for a fresh-ready state\n                stop();\n            }\n        })().finally(()=>{\n            isAdvancingRef.current = false;\n        });\n    }, [\n        progress,\n        ttsActive,\n        state.status,\n        state.currentStepIndex,\n        state.steps.length,\n        skipTo,\n        stop\n    ]);\n    const currentStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (state.currentStepIndex < 0) return undefined;\n        return state.steps[state.currentStepIndex];\n    }, [\n        state.currentStepIndex,\n        state.steps\n    ]);\n    return {\n        state,\n        currentStep,\n        start,\n        pause,\n        resume,\n        stop,\n        skipTo,\n        jumpTo,\n        progress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dFQUV5RTtBQUUvQjtBQUV5QjtBQWdCNUQsU0FBU08sbUJBQ2RDLE1BQXVDLEVBQ3ZDQyxVQUE4QixFQUM5QkMsSUFBNEM7SUFFNUMsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdSLCtDQUFRQSxDQUF1QjtRQUN2RFMsUUFBUTtRQUNSQyxrQkFBa0IsQ0FBQztRQUNuQkMsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNQyxRQUFRVixpRkFBa0JBO0lBQ2hDLE1BQU0sQ0FBQ1csVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNZSxnQkFBZ0JoQiw2Q0FBTUEsQ0FBZ0I7SUFDNUMsTUFBTWlCLGdCQUFnQmpCLDZDQUFNQSxDQUFTO0lBQ3JDLE1BQU1rQixtQkFBbUJsQiw2Q0FBTUEsQ0FBUztJQUN4QyxNQUFNbUIsbUJBQW1CbkIsNkNBQU1BLENBQWdCO0lBQy9DLE1BQU1vQixxQkFBcUJwQiw2Q0FBTUEsQ0FBUztJQUMxQyxNQUFNcUIsYUFBYXJCLDZDQUFNQSxDQUF1QjtJQUNoRCxNQUFNLENBQUNzQixXQUFXQyxhQUFhLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNdUIsZUFBZXhCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU15QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNMEIsZ0JBQWdCMUIsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTJCLHFCQUFxQjNCLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU00Qiw4QkFBOEI1Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUQsTUFBTTZCLGNBQWM3Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUMsTUFBTThCLHNCQUFzQjlCLDZDQUFNQSxDQUFTO0lBQzNDLE1BQU0rQixjQUFjL0IsNkNBQU1BLENBQVM7SUFDbkMsTUFBTWdDLGFBQWFoQyw2Q0FBTUEsQ0FBUztJQUNsQyxN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RixHQUFHO1FBQUMzQjtRQUFVUTtRQUFXZCxNQUFNRSxNQUFNO1FBQUVGLE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLLENBQUN5RCxNQUFNO1FBQUUrQztRQUFRVDtLQUFLO0lBRWhHLE1BQU1ZLGNBQWN4SCw4Q0FBT0EsQ0FBQztRQUMxQixJQUFJUyxNQUFNRyxnQkFBZ0IsR0FBRyxHQUFHLE9BQU9rRztRQUN2QyxPQUFPckcsTUFBTUksS0FBSyxDQUFDSixNQUFNRyxnQkFBZ0IsQ0FBQztJQUM1QyxHQUFHO1FBQUNILE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLO0tBQUM7SUFFeEMsT0FBTztRQUFFSjtRQUFPK0c7UUFBYWQ7UUFBT1M7UUFBT0M7UUFBUVI7UUFBTVM7UUFBUUM7UUFBUXZHO0lBQVM7QUFDcEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hZ2VudC91c2VBZ2VudENvbnRyb2xsZXIudHM/NGUyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHR5cGUgeyBQZGZDYXJvdXNlbFJlZiB9IGZyb20gJ0AvY29tcG9uZW50cy9QZGZDYXJvdXNlbCdcclxuaW1wb3J0IHsgZmV0Y2hBZ2VudFBsYW4gfSBmcm9tICcuL21vY2tBcGknXHJcbmltcG9ydCB0eXBlIHsgQWdlbnRDb250cm9sbGVyU3RhdGUsIEFnZW50U2Vzc2lvbkNvbmZpZywgQWdlbnRTdGVwIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgdXNlQXVkaW9Db250cm9sbGVyIH0gZnJvbSAnQC9saWIvYXVkaW8vdXNlQXVkaW9Db250cm9sbGVyJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIHN0YXRlOiBBZ2VudENvbnRyb2xsZXJTdGF0ZVxyXG4gIGN1cnJlbnRTdGVwPzogQWdlbnRTdGVwXHJcbiAgc3RhcnQ6IChjZmc/OiBQYXJ0aWFsPEFnZW50U2Vzc2lvbkNvbmZpZz4pID0+IFByb21pc2U8dm9pZD5cclxuICBwYXVzZTogKCkgPT4gdm9pZFxyXG4gIHJlc3VtZTogKCkgPT4gdm9pZFxyXG4gIHN0b3A6ICgpID0+IHZvaWRcclxuICBza2lwVG86IChpbmRleDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgLy8gVXNlci1pbml0aWF0ZWQganVtcCB0aGF0IHN1cHByZXNzZXMgYXV0by1hZHZhbmNlIGR1cmluZyB0cmFuc2l0aW9uXHJcbiAganVtcFRvOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIC8vIFNpbXVsYXRlZCBwcm9ncmVzcyBvZiBjdXJyZW50IHN0ZXA6IDAuLjFcclxuICBwcm9ncmVzczogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBZ2VudENvbnRyb2xsZXIoXHJcbiAgcGRmUmVmOiBSZWFjdC5SZWZPYmplY3Q8UGRmQ2Fyb3VzZWxSZWY+LFxyXG4gIGJhc2VDb25maWc6IEFnZW50U2Vzc2lvbkNvbmZpZyxcclxuICBvcHRzPzogeyBuYXZpZ2F0ZT86IChwYWdlOiBudW1iZXIpID0+IHZvaWQgfVxyXG4pOiBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8QWdlbnRDb250cm9sbGVyU3RhdGU+KHtcclxuICAgIHN0YXR1czogJ2lkbGUnLFxyXG4gICAgY3VycmVudFN0ZXBJbmRleDogLTEsXHJcbiAgICBzdGVwczogW10sXHJcbiAgfSlcclxuICBjb25zdCBhdWRpbyA9IHVzZUF1ZGlvQ29udHJvbGxlcigpXHJcbiAgY29uc3QgW3Byb2dyZXNzLCBzZXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKVxyXG4gIGNvbnN0IHByb2dyZXNzVGltZXIgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBwcm9ncmVzc1N0YXJ0ID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc0R1cmF0aW9uID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc1BhdXNlZEF0ID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgcHJvZ3Jlc3NQYXVzZUFjY3VtID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwZW5kaW5nTmF2ID0gdXNlUmVmPFByb21pc2U8dm9pZD4gfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IFt0dHNBY3RpdmUsIHNldFR0c0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCB0dHNBY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgaXNBZHZhbmNpbmdSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgdHRzVGV4dExlblJlZiA9IHVzZVJlZigwKVxyXG4gIGNvbnN0IHR0c0JvdW5kYXJ5U2VlblJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCB0dHNTdGFydFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGVzdGltYXRlZFRvdGFsTXNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IGNoYXJSYXRlUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCB0dHNUZXh0UmVmID0gdXNlUmVmPHN0cmluZz4oJycpXHJcbiAgY29uc3QgdHRzV29yZFN0YXJ0c1JlZiA9IHVzZVJlZjxudW1iZXJbXT4oW10pXHJcbiAgY29uc3QgdHRzVG90YWxXb3Jkc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgdXNlclNraXBSZWYgPSB1c2VSZWYoZmFsc2UpXHJcblxyXG4gIGNvbnN0IG5hdmlnYXRlVG8gPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBnbyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKG9wdHM/Lm5hdmlnYXRlKSB7XHJcbiAgICAgICAgb3B0cy5uYXZpZ2F0ZShwYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGFwaSA9IHBkZlJlZi5jdXJyZW50XHJcbiAgICAgICAgYXBpPy5nb1RvUGFnZShwYWdlKVxyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDE1MCkpXHJcbiAgICB9XHJcbiAgICBjb25zdCBwID0gZ28oKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgaWYgKHBlbmRpbmdOYXYuY3VycmVudCA9PT0gcCkgcGVuZGluZ05hdi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfSlcclxuICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IHBcclxuICAgIGF3YWl0IHBcclxuICB9LCBbb3B0cywgcGRmUmVmXSlcclxuXHJcbiAgY29uc3Qgc3RvcFByb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHByb2dyZXNzVGltZXIuY3VycmVudCkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVyLmN1cnJlbnQpXHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3QgdGlja1Byb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgIGNvbnN0IHBhdXNlZCA9IHByb2dyZXNzUGF1c2VkQXQuY3VycmVudFxyXG4gICAgY29uc3QgcGF1c2VBZGogPSBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCArIChwYXVzZWQgPyBub3cgLSBwYXVzZWQgOiAwKVxyXG4gICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIHByb2dyZXNzU3RhcnQuY3VycmVudCAtIHBhdXNlQWRqXHJcbiAgICBsZXQgcGN0ID0gTWF0aC5taW4oMSwgZWxhcHNlZCAvIE1hdGgubWF4KDEsIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCkpXHJcbiAgICBpZiAodHRzQWN0aXZlUmVmLmN1cnJlbnQgJiYgcGN0ID49IDEpIHBjdCA9IDAuOThcclxuICAgIHNldFByb2dyZXNzKHBjdClcclxuICAgIGlmIChwY3QgPCAxIHx8IHR0c0FjdGl2ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrUHJvZ3Jlc3MpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcblxyXG4gIGNvbnN0IHN0YXJ0UHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoZHVyYXRpb25NczogbnVtYmVyKSA9PiB7XHJcbiAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCA9IE1hdGgubWF4KDEwMDAsIGR1cmF0aW9uTXMpXHJcbiAgICBwcm9ncmVzc1N0YXJ0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgcHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID0gbnVsbFxyXG4gICAgcHJvZ3Jlc3NQYXVzZUFjY3VtLmN1cnJlbnQgPSAwXHJcbiAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1Byb2dyZXNzKVxyXG4gIH0sIFtzdG9wUHJvZ3Jlc3MsIHRpY2tQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IGNhbmNlbFNwZWVjaCA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxyXG5cclxuICBjb25zdCBzcGVha1RleHQgPSB1c2VDYWxsYmFjaygodGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLCBmYWxsYmFja01zPzogbnVtYmVyKSA9PiB7XHJcbiAgICAvLyBDbGVhciBhbnkgcHJpb3IgYm91bmRhcnkgZmFsbGJhY2sgdGltZXJcclxuICAgIGlmICh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCkge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KVxyXG4gICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIHR0c1RleHRMZW5SZWYuY3VycmVudCA9IHRleHQ/Lmxlbmd0aCA/PyAwXHJcbiAgICB0dHNUZXh0UmVmLmN1cnJlbnQgPSB0ZXh0IHx8ICcnXHJcbiAgICAvLyBQcmVjb21wdXRlIHdvcmQgc3RhcnRzIGZvciBib3VuZGFyeS10by13b3JkIG1hcHBpbmdcclxuICAgIHR0c1dvcmRTdGFydHNSZWYuY3VycmVudCA9IFtdXHJcbiAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSAwXHJcbiAgICBpZiAodGV4dCkge1xyXG4gICAgICBjb25zdCByZWdleCA9IC9cXGJcXHdbXFx3J1xcLV0qXFxiL2dcclxuICAgICAgbGV0IG06IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcclxuICAgICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG0uaW5kZXggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQucHVzaChtLmluZGV4KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0ZXh0KSB7XHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICByZXR1cm4gKCkgPT4ge31cclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoIXN5bnRoKSByZXR1cm4gKCkgPT4ge31cclxuICAgICAgaWYgKHN5bnRoLnNwZWFraW5nKSBzeW50aC5jYW5jZWwoKVxyXG4gICAgICBjb25zdCB1dHRlciA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UodGV4dClcclxuICAgICAgLy8gS2VlcCBhIGNvbnNpc3RlbnQgcmF0ZSBmb3IgcHJlZGljdGFiaWxpdHlcclxuICAgICAgdXR0ZXIucmF0ZSA9IDFcclxuICAgICAgdXR0ZXIub25zdGFydCA9ICgpID0+IHtcclxuICAgICAgICBzZXRUdHNBY3RpdmUodHJ1ZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAvLyBDbGVhciB1c2VyLWluaXRpYXRlZCBza2lwIHN1cHByZXNzaW9uIG9uY2UgdGhlIG5ldyBzdGVwIHN0YXJ0cyBzcGVha2luZ1xyXG4gICAgICAgIHVzZXJTa2lwUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgIHR0c1N0YXJ0UmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgICAgIGNoYXJSYXRlUmVmLmN1cnJlbnQgPSAwXHJcbiAgICAgICAgZXN0aW1hdGVkVG90YWxNc1JlZi5jdXJyZW50ID0gZmFsbGJhY2tNcyB8fCA1MDAwXHJcbiAgICAgICAgLy8gQWx3YXlzIHJ1biBhIHRpY2s7IGlmIGJvdW5kYXJpZXMgc2hvdyB1cCwgaXQgd2lsbCBhZGFwdCB0byB0aW1lLWJhc2VkIGVzdGltYXRpb25cclxuICAgICAgICBzdGFydFByb2dyZXNzKGVzdGltYXRlZFRvdGFsTXNSZWYuY3VycmVudClcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgYm91bmRhcnkgZXZlbnRzIHRvIHJlZmxlY3QgcmVhbC10aW1lIHByb2dyZXNzXHJcbiAgICAgIHV0dGVyLm9uYm91bmRhcnkgPSAoZXY6IGFueSkgPT4ge1xyXG4gICAgICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIC8vIFN0b3AgdGltZXIgZmFsbGJhY2s7IGJvdW5kYXJ5IHdpbGwgZHJpdmUgcHJvZ3Jlc3NcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIGNvbnN0IGlkeDogbnVtYmVyID0gdHlwZW9mIGV2Py5jaGFySW5kZXggPT09ICdudW1iZXInID8gZXYuY2hhckluZGV4IDogMFxyXG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IHR0c1dvcmRTdGFydHNSZWYuY3VycmVudFxyXG4gICAgICAgIGNvbnN0IHRvdGFsV29yZHMgPSBNYXRoLm1heCgxLCB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgLy8gQ291bnQgd29yZHMgd2hvc2Ugc3RhcnQgaW5kZXggaXMgPD0gY3VycmVudCBjaGFyIGluZGV4XHJcbiAgICAgICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBzdGFydHMubGVuZ3RoXHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxXHJcbiAgICAgICAgICBpZiAoc3RhcnRzW21pZF0gPD0gaWR4KSBsb3cgPSBtaWQgKyAxXHJcbiAgICAgICAgICBlbHNlIGhpZ2ggPSBtaWRcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3Bva2VuV29yZHMgPSBNYXRoLm1pbihsb3csIHRvdGFsV29yZHMpXHJcbiAgICAgICAgbGV0IHBjdFdvcmRzID0gc3Bva2VuV29yZHMgLyB0b3RhbFdvcmRzXHJcbiAgICAgICAgaWYgKHR0c0FjdGl2ZVJlZi5jdXJyZW50ICYmIHBjdFdvcmRzID49IDEpIHBjdFdvcmRzID0gMC45OFxyXG4gICAgICAgIHNldFByb2dyZXNzKHBjdFdvcmRzKVxyXG4gICAgICB9XHJcbiAgICAgIHV0dGVyLm9uZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgLy8gQ29tcGxldGUgcHJvZ3Jlc3MgYW5kIHN0b3AgdGltZXI7IGF1dG8tYWR2YW5jZSBlZmZlY3Qgd2lsbCBwaWNrIHRoaXMgdXBcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIHNldFByb2dyZXNzKDEpXHJcbiAgICAgIH1cclxuICAgICAgc3ludGguc3BlYWsodXR0ZXIpXHJcblxyXG4gICAgICAvLyBJZiBib3VuZGFyeSBldmVudHMgYXJlbuKAmXQgc3VwcG9ydGVkLCBzdGFydCBhIGZhbGxiYWNrIHByb2dyZXNzIHRpbWVyIGFmdGVyIGEgc2hvcnQgZGVsYXlcclxuICAgICAgaWYgKGZhbGxiYWNrTXMgJiYgZmFsbGJhY2tNcyA+IDApIHtcclxuICAgICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgc3RhcnRQcm9ncmVzcyhmYWxsYmFja01zKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDcwMClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzeW50aC5jYW5jZWwoKVxyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBpZiAodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudClcclxuICAgICAgICAgICAgdHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYW5jZWxcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgcmV0dXJuICgpID0+IHt9XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0UHJvZ3Jlc3MsIHN0b3BQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHBsYXlTdGVwID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAoc3RlcDogQWdlbnRTdGVwKSA9PiB7XHJcbiAgICAgIC8vIEVuc3VyZSBmcmVzaCBwcm9ncmVzcy90dHMgc3RhdGUgZm9yIHRoaXMgc3RlcCB0byBhdm9pZCBhdXRvLWFkdmFuY2UgcmFjZXNcclxuICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICduYXZpZ2F0aW5nJyB9KSlcclxuICAgICAgYXdhaXQgbmF2aWdhdGVUbyhzdGVwLnBhZ2UpXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwbGF5aW5nJyB9KSlcclxuICAgICAgLy8gUHJlZmVyIFRUUy1kcml2ZW4gcHJvZ3Jlc3MgdmlhIGJvdW5kYXJpZXM7IGZhbGxiYWNrIHRvIGEgdGltZXIgaWYgYm91bmRhcmllcyBhcmVu4oCZdCBzdXBwb3J0ZWRcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50ID0gc3BlYWtUZXh0KHN0ZXAudHRzVGV4dCB8fCBzdGVwLnRyYW5zY3JpcHQsIHN0ZXAuc3BlYWtNcyA/PyA1MDAwKVxyXG4gICAgICAvLyBPcHRpb25hbGx5IHRyeSBhdWRpbyBhcyBhIHN1YnRsZSBiYWNrZ3JvdW5kIGJlZXAgaWYgYXZhaWxhYmxlXHJcbiAgICAgIC8vIGJ1dCB3ZSBubyBsb25nZXIgcmVseSBvbiBhdWRpbyBlbmQgdG8gYWR2YW5jZVxyXG4gICAgICBhdWRpby5wbGF5KHN0ZXAuYXVkaW9VcmwpLmNhdGNoKCgpID0+IHt9KVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgbmF2aWdhdGVUbywgc3BlYWtUZXh0LCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBzdGFydCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGNmZz86IFBhcnRpYWw8QWdlbnRTZXNzaW9uQ29uZmlnPikgPT4ge1xyXG4gICAgICAvLyBDbGVhbiB1cCBhbnkgcHJpb3IgcnVuIHRvIGVuc3VyZSBmcmVzaCBzdGF0ZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF1ZGlvLnN0b3AoKVxyXG4gICAgICB9IGNhdGNoIHt9XHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgaXNBZHZhbmNpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IG51bGxcclxuXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdmZXRjaGluZycsIGVycm9yOiB1bmRlZmluZWQgfSkpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGxhbiA9IGF3YWl0IGZldGNoQWdlbnRQbGFuKHsgLi4uYmFzZUNvbmZpZywgLi4uY2ZnIH0pXHJcbiAgICAgICAgaWYgKCFwbGFuLnN0ZXBzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdObyBzdGVwcyByZXR1cm5lZCcpXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbmQgbGV0IHBsYXlTdGVwIGhhbmRsZSBuYXZpZ2F0aW9uL3Byb2dyZXNzOyB3ZSBvbmx5IGNhbGwgaXQgb25jZSBoZXJlXHJcbiAgICAgICAgc2V0U3RhdGUoeyBzdGF0dXM6ICduYXZpZ2F0aW5nJywgY3VycmVudFN0ZXBJbmRleDogMCwgc3RlcHM6IHBsYW4uc3RlcHMgfSlcclxuICAgICAgICBhd2FpdCBwbGF5U3RlcChwbGFuLnN0ZXBzWzBdKVxyXG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogZT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicgfSkpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIGJhc2VDb25maWcsIHBsYXlTdGVwLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBwYXVzZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnBhdXNlKClcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoc3ludGggJiYgc3ludGguc3BlYWtpbmcgJiYgIXN5bnRoLnBhdXNlZCkgc3ludGgucGF1c2UoKVxyXG4gICAgfSBjYXRjaCB7fVxyXG4gICAgLy8gUGF1c2UgZmFsbGJhY2sgdGltZXIgcHJvZ3Jlc3MgaWYgcnVubmluZ1xyXG4gICAgaWYgKCF0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID09IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9ncmVzc1RpbWVyLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVyLmN1cnJlbnQpXHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGF1c2VkJyB9KSlcclxuICB9LCBbYXVkaW9dKVxyXG5cclxuICBjb25zdCByZXN1bWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBhdWRpby5yZXN1bWUoKVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3ludGggPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzXHJcbiAgICAgIGlmIChzeW50aCAmJiBzeW50aC5wYXVzZWQpIHN5bnRoLnJlc3VtZSgpXHJcbiAgICB9IGNhdGNoIHt9XHJcbiAgICAvLyBSZXN1bWUgZmFsbGJhY2sgdGltZXIgcHJvZ3Jlc3MgaWYgYm91bmRhcnkgbm90IGF2YWlsYWJsZVxyXG4gICAgaWYgKCF0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ICE9IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2dyZXNzUGF1c2VkQXQuY3VycmVudFxyXG4gICAgICAgIHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXByb2dyZXNzVGltZXIuY3VycmVudCAmJiBwcm9ncmVzcyA8IDEpIHtcclxuICAgICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1Byb2dyZXNzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGxheWluZycgfSkpXHJcbiAgfSwgW2F1ZGlvLCBwcm9ncmVzcywgdGlja1Byb2dyZXNzXSlcclxuXHJcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnN0b3AoKVxyXG4gICAgc3RvcFByb2dyZXNzKClcclxuICAgIHNldFByb2dyZXNzKDApXHJcbiAgICBjYW5jZWxTcGVlY2guY3VycmVudD8uKClcclxuICAgIHNldFN0YXRlKHsgc3RhdHVzOiAnc3RvcHBlZCcsIGN1cnJlbnRTdGVwSW5kZXg6IC0xLCBzdGVwczogW10gfSlcclxuICB9LCBbYXVkaW8sIHN0b3BQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHNraXBUbyA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3Qgc3RlcHMgPSBzdGF0ZS5zdGVwc1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0ZXBzLmxlbmd0aCkgcmV0dXJuXHJcbiAgICAgIC8vIFN0b3AgYXVkaW8gYW5kIHNwZWVjaCBhbmQgcmVzZXQgcHJvZ3Jlc3MgYmVmb3JlIHN3aXRjaGluZ1xyXG4gICAgICBhdWRpby5zdG9wKClcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgIHNldFByb2dyZXNzKDApXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBjdXJyZW50U3RlcEluZGV4OiBpbmRleCB9KSlcclxuICAgICAgYXdhaXQgcGxheVN0ZXAoc3RlcHNbaW5kZXhdKVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgcGxheVN0ZXAsIHN0YXRlLnN0ZXBzLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICAvLyBQdWJsaWMgdXNlci1pbml0aWF0ZWQganVtcDogcHJldmVudCBhdXRvLWFkdmFuY2UgZnJvbSBjaGFpbmluZyBvdmVyIHRoZSB1c2Vy4oCZcyBzZWxlY3Rpb25cclxuICBjb25zdCBqdW1wVG8gPSB1c2VDYWxsYmFjayhhc3luYyAoaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgdXNlclNraXBSZWYuY3VycmVudCA9IHRydWVcclxuICAgIGF3YWl0IHNraXBUbyhpbmRleClcclxuICB9LCBbc2tpcFRvXSlcclxuXHJcbiAgLy8gQXV0by1hZHZhbmNlIHdoZW4gcHJvZ3Jlc3MgY29tcGxldGVzIEFORCBUVFMgKGlmIGFueSkgaGFzIGVuZGVkLlxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAncGxheWluZycgfHwgcHJvZ3Jlc3MgPCAxIHx8IHR0c0FjdGl2ZSkgcmV0dXJuXHJcbiAgICAvLyBJZiB1c2VyIGp1c3QganVtcGVkLCBkbyBub3QgYXV0by1hZHZhbmNlIGZyb20gdGhlIG9sZCBzdGVwIGNvbXBsZXRpb25cclxuICAgIGlmICh1c2VyU2tpcFJlZi5jdXJyZW50KSByZXR1cm5cclxuICAgIGlmIChpc0FkdmFuY2luZ1JlZi5jdXJyZW50KSByZXR1cm5cclxuICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICA7KGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbmV4dCA9IHN0YXRlLmN1cnJlbnRTdGVwSW5kZXggKyAxXHJcbiAgICAgIGlmIChuZXh0IDwgc3RhdGUuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgYXdhaXQgc2tpcFRvKG5leHQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRW5kIG9mIHBsYW46IGJlaGF2ZSBsaWtlIFN0b3AgZm9yIGEgZnJlc2gtcmVhZHkgc3RhdGVcclxuICAgICAgICBzdG9wKClcclxuICAgICAgfVxyXG4gICAgfSkoKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgaXNBZHZhbmNpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICB9KVxyXG4gIH0sIFtwcm9ncmVzcywgdHRzQWN0aXZlLCBzdGF0ZS5zdGF0dXMsIHN0YXRlLmN1cnJlbnRTdGVwSW5kZXgsIHN0YXRlLnN0ZXBzLmxlbmd0aCwgc2tpcFRvLCBzdG9wXSlcclxuXHJcbiAgY29uc3QgY3VycmVudFN0ZXAgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGlmIChzdGF0ZS5jdXJyZW50U3RlcEluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgcmV0dXJuIHN0YXRlLnN0ZXBzW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXhdXHJcbiAgfSwgW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXgsIHN0YXRlLnN0ZXBzXSlcclxuXHJcbiAgcmV0dXJuIHsgc3RhdGUsIGN1cnJlbnRTdGVwLCBzdGFydCwgcGF1c2UsIHJlc3VtZSwgc3RvcCwgc2tpcFRvLCBqdW1wVG8sIHByb2dyZXNzIH1cclxufVxyXG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlU3RhdGUiLCJmZXRjaEFnZW50UGxhbiIsInVzZUF1ZGlvQ29udHJvbGxlciIsInVzZUFnZW50Q29udHJvbGxlciIsInBkZlJlZiIsImJhc2VDb25maWciLCJvcHRzIiwic3RhdGUiLCJzZXRTdGF0ZSIsInN0YXR1cyIsImN1cnJlbnRTdGVwSW5kZXgiLCJzdGVwcyIsImF1ZGlvIiwicHJvZ3Jlc3MiLCJzZXRQcm9ncmVzcyIsInByb2dyZXNzVGltZXIiLCJwcm9ncmVzc1N0YXJ0IiwicHJvZ3Jlc3NEdXJhdGlvbiIsInByb2dyZXNzUGF1c2VkQXQiLCJwcm9ncmVzc1BhdXNlQWNjdW0iLCJwZW5kaW5nTmF2IiwidHRzQWN0aXZlIiwic2V0VHRzQWN0aXZlIiwidHRzQWN0aXZlUmVmIiwiaXNBZHZhbmNpbmdSZWYiLCJ0dHNUZXh0TGVuUmVmIiwidHRzQm91bmRhcnlTZWVuUmVmIiwidHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmIiwidHRzU3RhcnRSZWYiLCJlc3RpbWF0ZWRUb3RhbE1zUmVmIiwiY2hhclJhdGVSZWYiLCJ0dHNUZXh0UmVmIiwidHRzV29yZFN0YXJ0c1JlZiIsInR0c1RvdGFsV29yZHNSZWYiLCJ1c2VyU2tpcFJlZiIsIm5hdmlnYXRlVG8iLCJwYWdlIiwiZ28iLCJuYXZpZ2F0ZSIsImFwaSIsImN1cnJlbnQiLCJnb1RvUGFnZSIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInAiLCJmaW5hbGx5Iiwic3RvcFByb2dyZXNzIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0aWNrUHJvZ3Jlc3MiLCJub3ciLCJwZXJmb3JtYW5jZSIsInBhdXNlZCIsInBhdXNlQWRqIiwiZWxhcHNlZCIsInBjdCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdGFydFByb2dyZXNzIiwiZHVyYXRpb25NcyIsImNhbmNlbFNwZWVjaCIsInNwZWFrVGV4dCIsInRleHQiLCJmYWxsYmFja01zIiwid2luZG93IiwiY2xlYXJUaW1lb3V0IiwibGVuZ3RoIiwicmVnZXgiLCJtIiwiZXhlYyIsImluZGV4IiwicHVzaCIsInN5bnRoIiwic3BlZWNoU3ludGhlc2lzIiwic3BlYWtpbmciLCJjYW5jZWwiLCJ1dHRlciIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInJhdGUiLCJvbnN0YXJ0Iiwib25ib3VuZGFyeSIsImV2IiwiaWR4IiwiY2hhckluZGV4Iiwic3RhcnRzIiwidG90YWxXb3JkcyIsImxvdyIsImhpZ2giLCJtaWQiLCJzcG9rZW5Xb3JkcyIsInBjdFdvcmRzIiwib25lbmQiLCJzcGVhayIsInBsYXlTdGVwIiwic3RlcCIsInMiLCJ0dHNUZXh0IiwidHJhbnNjcmlwdCIsInNwZWFrTXMiLCJwbGF5IiwiYXVkaW9VcmwiLCJjYXRjaCIsInN0YXJ0IiwiY2ZnIiwic3RvcCIsImVycm9yIiwidW5kZWZpbmVkIiwicGxhbiIsIkVycm9yIiwiZSIsIm1lc3NhZ2UiLCJwYXVzZSIsInJlc3VtZSIsInNraXBUbyIsImp1bXBUbyIsIm5leHQiLCJjdXJyZW50U3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/useAgentController.ts\n"));

/***/ })

});