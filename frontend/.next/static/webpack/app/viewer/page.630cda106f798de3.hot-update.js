"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/useAgentController.ts":
/*!*********************************************!*\
  !*** ./src/lib/agent/useAgentController.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgentController: function() { return /* binding */ useAgentController; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mockApi */ \"(app-pages-browser)/./src/lib/agent/mockApi.ts\");\n/* harmony import */ var _lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/audio/useAudioController */ \"(app-pages-browser)/./src/lib/audio/useAudioController.ts\");\n/* __next_internal_client_entry_do_not_use__ useAgentController auto */ \n\n\nfunction useAgentController(pdfRef, baseConfig, opts) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        status: \"idle\",\n        currentStepIndex: -1,\n        steps: []\n    });\n    const audio = (0,_lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__.useAudioController)();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const progressTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressPausedAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressPauseAccum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pendingNav = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [ttsActive, setTtsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ttsActiveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isAdvancingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsTextLenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsBoundarySeenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsBoundaryFallbackTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ttsStartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const estimatedTotalMsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const charRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsTextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const ttsWordStartsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const ttsTotalWordsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const navigateTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (page)=>{\n        const go = async ()=>{\n            if (opts === null || opts === void 0 ? void 0 : opts.navigate) {\n                opts.navigate(page);\n            } else {\n                const api = pdfRef.current;\n                api === null || api === void 0 ? void 0 : api.goToPage(page);\n            }\n            await new Promise((r)=>setTimeout(r, 150));\n        };\n        const p = go().finally(()=>{\n            if (pendingNav.current === p) pendingNav.current = null;\n        });\n        pendingNav.current = p;\n        await p;\n    }, [\n        opts,\n        pdfRef\n    ]);\n    const stopProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressTimer.current) {\n            cancelAnimationFrame(progressTimer.current);\n            progressTimer.current = null;\n        }\n    }, []);\n    const tickProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const now = performance.now();\n        const paused = progressPausedAt.current;\n        const pauseAdj = progressPauseAccum.current + (paused ? now - paused : 0);\n        const elapsed = now - progressStart.current - pauseAdj;\n        let pct = Math.min(1, elapsed / Math.max(1, progressDuration.current));\n        if (ttsActiveRef.current && pct >= 1) pct = 0.98;\n        setProgress(pct);\n        if (pct < 1 || ttsActiveRef.current) {\n            progressTimer.current = requestAnimationFrame(tickProgress);\n        } else {\n            progressTimer.current = null;\n        }\n    }, []);\n    const startProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((durationMs)=>{\n        stopProgress();\n        setProgress(0);\n        progressDuration.current = Math.max(1000, durationMs);\n        progressStart.current = performance.now();\n        progressPausedAt.current = null;\n        progressPauseAccum.current = 0;\n        progressTimer.current = requestAnimationFrame(tickProgress);\n    }, [\n        stopProgress,\n        tickProgress\n    ]);\n    const cancelSpeech = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const speakText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text, fallbackMs)=>{\n        // Clear any prior boundary fallback timer\n        if (ttsBoundaryFallbackTimerRef.current) {\n            window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n            ttsBoundaryFallbackTimerRef.current = null;\n        }\n        ttsBoundarySeenRef.current = false;\n        var _text_length;\n        ttsTextLenRef.current = (_text_length = text === null || text === void 0 ? void 0 : text.length) !== null && _text_length !== void 0 ? _text_length : 0;\n        ttsTextRef.current = text || \"\";\n        // Precompute word starts for boundary-to-word mapping\n        ttsWordStartsRef.current = [];\n        ttsTotalWordsRef.current = 0;\n        if (text) {\n            const regex = /\\b\\w[\\w'\\-]*\\b/g;\n            let m;\n            while((m = regex.exec(text)) !== null){\n                if (typeof m.index === \"number\") {\n                    ttsWordStartsRef.current.push(m.index);\n                }\n            }\n            ttsTotalWordsRef.current = ttsWordStartsRef.current.length;\n        }\n        if (!text) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n        try {\n            const synth = window.speechSynthesis;\n            if (!synth) return ()=>{};\n            if (synth.speaking) synth.cancel();\n            const utter = new SpeechSynthesisUtterance(text);\n            // Keep a consistent rate for predictability\n            utter.rate = 1;\n            utter.onstart = ()=>{\n                setTtsActive(true);\n                ttsActiveRef.current = true;\n                ttsStartRef.current = performance.now();\n                charRateRef.current = 0;\n                estimatedTotalMsRef.current = fallbackMs || 5000;\n                // Always run a tick; if boundaries show up, it will adapt to time-based estimation\n                startProgress(estimatedTotalMsRef.current);\n            };\n            // Use boundary events to reflect real-time progress\n            utter.onboundary = (ev)=>{\n                ttsBoundarySeenRef.current = true;\n                // Stop timer fallback; boundary will drive progress\n                stopProgress();\n                const idx = typeof (ev === null || ev === void 0 ? void 0 : ev.charIndex) === \"number\" ? ev.charIndex : 0;\n                const starts = ttsWordStartsRef.current;\n                const totalWords = Math.max(1, ttsTotalWordsRef.current);\n                // Count words whose start index is <= current char index\n                let low = 0, high = starts.length;\n                while(low < high){\n                    const mid = low + high >> 1;\n                    if (starts[mid] <= idx) low = mid + 1;\n                    else high = mid;\n                }\n                const spokenWords = Math.min(low, totalWords);\n                let pctWords = spokenWords / totalWords;\n                if (ttsActiveRef.current && pctWords >= 1) pctWords = 0.98;\n                setProgress(pctWords);\n            };\n            utter.onend = ()=>{\n                setTtsActive(false);\n                ttsActiveRef.current = false;\n                // Complete progress and stop timer; auto-advance effect will pick this up\n                stopProgress();\n                setProgress(1);\n            };\n            synth.speak(utter);\n            // If boundary events aren’t supported, start a fallback progress timer after a short delay\n            if (fallbackMs && fallbackMs > 0) {\n                ttsBoundaryFallbackTimerRef.current = window.setTimeout(()=>{\n                    if (!ttsBoundarySeenRef.current) {\n                        startProgress(fallbackMs);\n                    }\n                }, 700);\n            }\n            const cancel = ()=>{\n                try {\n                    synth.cancel();\n                } finally{\n                    setTtsActive(false);\n                    ttsActiveRef.current = false;\n                    if (ttsBoundaryFallbackTimerRef.current) {\n                        window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n                        ttsBoundaryFallbackTimerRef.current = null;\n                    }\n                }\n            };\n            return cancel;\n        } catch (e) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n    }, [\n        startProgress,\n        stopProgress\n    ]);\n    const playStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (step)=>{\n        var // Prefer TTS-driven progress via boundaries; fallback to a timer if boundaries aren’t supported\n        _cancelSpeech_current;\n        // Ensure fresh progress/tts state for this step to avoid auto-advance races\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        setState((s)=>({\n                ...s,\n                status: \"navigating\"\n            }));\n        await navigateTo(step.page);\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        var _step_speakMs;\n        cancelSpeech.current = speakText(step.ttsText || step.transcript, (_step_speakMs = step.speakMs) !== null && _step_speakMs !== void 0 ? _step_speakMs : 5000);\n        // Optionally try audio as a subtle background beep if available\n        // but we no longer rely on audio end to advance\n        audio.play(step.audioUrl).catch(()=>{});\n    }, [\n        audio,\n        navigateTo,\n        speakText,\n        stopProgress\n    ]);\n    const start = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cfg)=>{\n        var _cancelSpeech_current;\n        // Clean up any prior run to ensure fresh state\n        try {\n            audio.stop();\n        } catch (e) {}\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        isAdvancingRef.current = false;\n        pendingNav.current = null;\n        setState((s)=>({\n                ...s,\n                status: \"fetching\",\n                error: undefined\n            }));\n        try {\n            const plan = await (0,_mockApi__WEBPACK_IMPORTED_MODULE_1__.fetchAgentPlan)({\n                ...baseConfig,\n                ...cfg\n            });\n            if (!plan.steps.length) throw new Error(\"No steps returned\");\n            // Initialize and let playStep handle navigation/progress; we only call it once here\n            setState({\n                status: \"navigating\",\n                currentStepIndex: 0,\n                steps: plan.steps\n            });\n            await playStep(plan.steps[0]);\n        } catch (e) {\n            setState((s)=>({\n                    ...s,\n                    status: \"error\",\n                    error: (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\"\n                }));\n        }\n    }, [\n        audio,\n        baseConfig,\n        playStep,\n        stopProgress\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.pause();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.speaking && !synth.paused) synth.pause();\n        } catch (e) {}\n        // Pause fallback timer progress if running\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current == null) {\n                progressPausedAt.current = performance.now();\n            }\n            if (progressTimer.current) {\n                cancelAnimationFrame(progressTimer.current);\n                progressTimer.current = null;\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"paused\"\n            }));\n    }, [\n        audio\n    ]);\n    const resume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.resume();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.paused) synth.resume();\n        } catch (e) {}\n        // Resume fallback timer progress if boundary not available\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current != null) {\n                progressPauseAccum.current += performance.now() - progressPausedAt.current;\n                progressPausedAt.current = null;\n            }\n            if (!progressTimer.current && progress < 1) {\n                progressTimer.current = requestAnimationFrame(tickProgress);\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n    }, [\n        audio,\n        progress,\n        tickProgress\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cancelSpeech_current;\n        audio.stop();\n        stopProgress();\n        setProgress(0);\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        setState({\n            status: \"stopped\",\n            currentStepIndex: -1,\n            steps: []\n        });\n    }, [\n        audio,\n        stopProgress\n    ]);\n    const skipTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        var _cancelSpeech_current;\n        const steps = state.steps;\n        if (index < 0 || index >= steps.length) return;\n        // Stop audio and speech and reset progress before switching\n        audio.stop();\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setState((s)=>({\n                ...s,\n                currentStepIndex: index\n            }));\n        await playStep(steps[index]);\n    }, [\n        audio,\n        playStep,\n        state.steps,\n        stopProgress\n    ]);\n    // Auto-advance when progress completes AND TTS (if any) has ended.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (state.status !== \"playing\" || progress < 1 || ttsActive) return;\n        if (isAdvancingRef.current) return;\n        isAdvancingRef.current = true;\n        (async ()=>{\n            const next = state.currentStepIndex + 1;\n            if (next < state.steps.length) {\n                await skipTo(next);\n            } else {\n                // End of plan: behave like Stop for a fresh-ready state\n                stop();\n            }\n        })().finally(()=>{\n            isAdvancingRef.current = false;\n        });\n    }, [\n        progress,\n        ttsActive,\n        state.status,\n        state.currentStepIndex,\n        state.steps.length,\n        skipTo,\n        stop\n    ]);\n    const currentStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (state.currentStepIndex < 0) return undefined;\n        return state.steps[state.currentStepIndex];\n    }, [\n        state.currentStepIndex,\n        state.steps\n    ]);\n    return {\n        state,\n        currentStep,\n        start,\n        pause,\n        resume,\n        stop,\n        skipTo,\n        progress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dFQUV5RTtBQUUvQjtBQUV5QjtBQWM1RCxTQUFTTyxtQkFDZEMsTUFBdUMsRUFDdkNDLFVBQThCLEVBQzlCQyxJQUE0QztJQUU1QyxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR1IsK0NBQVFBLENBQXVCO1FBQ3ZEUyxRQUFRO1FBQ1JDLGtCQUFrQixDQUFDO1FBQ25CQyxPQUFPLEVBQUU7SUFDWDtJQUNBLE1BQU1DLFFBQVFWLGlGQUFrQkE7SUFDaEMsTUFBTSxDQUFDVyxVQUFVQyxZQUFZLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU1lLGdCQUFnQmhCLDZDQUFNQSxDQUFnQjtJQUM1QyxNQUFNaUIsZ0JBQWdCakIsNkNBQU1BLENBQVM7SUFDckMsTUFBTWtCLG1CQUFtQmxCLDZDQUFNQSxDQUFTO0lBQ3hDLE1BQU1tQixtQkFBbUJuQiw2Q0FBTUEsQ0FBZ0I7SUFDL0MsTUFBTW9CLHFCQUFxQnBCLDZDQUFNQSxDQUFTO0lBQzFDLE1BQU1xQixhQUFhckIsNkNBQU1BLENBQXVCO0lBQ2hELE1BQU0sQ0FBQ3NCLFdBQVdDLGFBQWEsR0FBR3RCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU11QixlQUFleEIsNkNBQU1BLENBQUM7SUFDNUIsTUFBTXlCLGlCQUFpQnpCLDZDQUFNQSxDQUFDO0lBQzlCLE1BQU0wQixnQkFBZ0IxQiw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNMkIscUJBQXFCM0IsNkNBQU1BLENBQUM7SUFDbEMsTUFBTTRCLDhCQUE4QjVCLDZDQUFNQSxDQUFnQjtJQUMxRCxNQUFNNkIsY0FBYzdCLDZDQUFNQSxDQUFnQjtJQUMxQyxNQUFNOEIsc0JBQXNCOUIsNkNBQU1BLENBQVM7SUFDM0MsTUFBTStCLGNBQWMvQiw2Q0FBTUEsQ0FBUztJQUNuQyxNQUFNZ0MsYUFBYWhDLDZDQUFNQSxDQUFTO0lBQ2xDLE1B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QUFDSCxNQUFNRyxnQkFBZ0I7UUFBRUgsTUFBTUksS0FBSztLQUFDO0lBRXhDLE9BQU87UUFBRUo7UUFBTzZHO1FBQWFiO1FBQU9TO1FBQU9DO1FBQVFSO1FBQU1TO1FBQVFyRztJQUFTO0FBQzVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzPzRlMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB0eXBlIHsgUGRmQ2Fyb3VzZWxSZWYgfSBmcm9tICdAL2NvbXBvbmVudHMvUGRmQ2Fyb3VzZWwnXHJcbmltcG9ydCB7IGZldGNoQWdlbnRQbGFuIH0gZnJvbSAnLi9tb2NrQXBpJ1xyXG5pbXBvcnQgdHlwZSB7IEFnZW50Q29udHJvbGxlclN0YXRlLCBBZ2VudFNlc3Npb25Db25maWcsIEFnZW50U3RlcCB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IHVzZUF1ZGlvQ29udHJvbGxlciB9IGZyb20gJ0AvbGliL2F1ZGlvL3VzZUF1ZGlvQ29udHJvbGxlcidcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWdlbnRDb250cm9sbGVyQXBpIHtcclxuICBzdGF0ZTogQWdlbnRDb250cm9sbGVyU3RhdGVcclxuICBjdXJyZW50U3RlcD86IEFnZW50U3RlcFxyXG4gIHN0YXJ0OiAoY2ZnPzogUGFydGlhbDxBZ2VudFNlc3Npb25Db25maWc+KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgcGF1c2U6ICgpID0+IHZvaWRcclxuICByZXN1bWU6ICgpID0+IHZvaWRcclxuICBzdG9wOiAoKSA9PiB2b2lkXHJcbiAgc2tpcFRvOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIC8vIFNpbXVsYXRlZCBwcm9ncmVzcyBvZiBjdXJyZW50IHN0ZXA6IDAuLjFcclxuICBwcm9ncmVzczogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBZ2VudENvbnRyb2xsZXIoXHJcbiAgcGRmUmVmOiBSZWFjdC5SZWZPYmplY3Q8UGRmQ2Fyb3VzZWxSZWY+LFxyXG4gIGJhc2VDb25maWc6IEFnZW50U2Vzc2lvbkNvbmZpZyxcclxuICBvcHRzPzogeyBuYXZpZ2F0ZT86IChwYWdlOiBudW1iZXIpID0+IHZvaWQgfVxyXG4pOiBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8QWdlbnRDb250cm9sbGVyU3RhdGU+KHtcclxuICAgIHN0YXR1czogJ2lkbGUnLFxyXG4gICAgY3VycmVudFN0ZXBJbmRleDogLTEsXHJcbiAgICBzdGVwczogW10sXHJcbiAgfSlcclxuICBjb25zdCBhdWRpbyA9IHVzZUF1ZGlvQ29udHJvbGxlcigpXHJcbiAgY29uc3QgW3Byb2dyZXNzLCBzZXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKVxyXG4gIGNvbnN0IHByb2dyZXNzVGltZXIgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBwcm9ncmVzc1N0YXJ0ID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc0R1cmF0aW9uID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc1BhdXNlZEF0ID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgcHJvZ3Jlc3NQYXVzZUFjY3VtID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwZW5kaW5nTmF2ID0gdXNlUmVmPFByb21pc2U8dm9pZD4gfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IFt0dHNBY3RpdmUsIHNldFR0c0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCB0dHNBY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgaXNBZHZhbmNpbmdSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgdHRzVGV4dExlblJlZiA9IHVzZVJlZigwKVxyXG4gIGNvbnN0IHR0c0JvdW5kYXJ5U2VlblJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCB0dHNTdGFydFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGVzdGltYXRlZFRvdGFsTXNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IGNoYXJSYXRlUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCB0dHNUZXh0UmVmID0gdXNlUmVmPHN0cmluZz4oJycpXHJcbiAgY29uc3QgdHRzV29yZFN0YXJ0c1JlZiA9IHVzZVJlZjxudW1iZXJbXT4oW10pXHJcbiAgY29uc3QgdHRzVG90YWxXb3Jkc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcblxyXG4gIGNvbnN0IG5hdmlnYXRlVG8gPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBnbyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKG9wdHM/Lm5hdmlnYXRlKSB7XHJcbiAgICAgICAgb3B0cy5uYXZpZ2F0ZShwYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGFwaSA9IHBkZlJlZi5jdXJyZW50XHJcbiAgICAgICAgYXBpPy5nb1RvUGFnZShwYWdlKVxyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDE1MCkpXHJcbiAgICB9XHJcbiAgICBjb25zdCBwID0gZ28oKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgaWYgKHBlbmRpbmdOYXYuY3VycmVudCA9PT0gcCkgcGVuZGluZ05hdi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfSlcclxuICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IHBcclxuICAgIGF3YWl0IHBcclxuICB9LCBbb3B0cywgcGRmUmVmXSlcclxuXHJcbiAgY29uc3Qgc3RvcFByb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHByb2dyZXNzVGltZXIuY3VycmVudCkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVyLmN1cnJlbnQpXHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3QgdGlja1Byb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgIGNvbnN0IHBhdXNlZCA9IHByb2dyZXNzUGF1c2VkQXQuY3VycmVudFxyXG4gICAgY29uc3QgcGF1c2VBZGogPSBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCArIChwYXVzZWQgPyBub3cgLSBwYXVzZWQgOiAwKVxyXG4gICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIHByb2dyZXNzU3RhcnQuY3VycmVudCAtIHBhdXNlQWRqXHJcbiAgICBsZXQgcGN0ID0gTWF0aC5taW4oMSwgZWxhcHNlZCAvIE1hdGgubWF4KDEsIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCkpXHJcbiAgICBpZiAodHRzQWN0aXZlUmVmLmN1cnJlbnQgJiYgcGN0ID49IDEpIHBjdCA9IDAuOThcclxuICAgIHNldFByb2dyZXNzKHBjdClcclxuICAgIGlmIChwY3QgPCAxIHx8IHR0c0FjdGl2ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrUHJvZ3Jlc3MpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcblxyXG4gIGNvbnN0IHN0YXJ0UHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoZHVyYXRpb25NczogbnVtYmVyKSA9PiB7XHJcbiAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCA9IE1hdGgubWF4KDEwMDAsIGR1cmF0aW9uTXMpXHJcbiAgICBwcm9ncmVzc1N0YXJ0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgcHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID0gbnVsbFxyXG4gICAgcHJvZ3Jlc3NQYXVzZUFjY3VtLmN1cnJlbnQgPSAwXHJcbiAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1Byb2dyZXNzKVxyXG4gIH0sIFtzdG9wUHJvZ3Jlc3MsIHRpY2tQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IGNhbmNlbFNwZWVjaCA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxyXG5cclxuICBjb25zdCBzcGVha1RleHQgPSB1c2VDYWxsYmFjaygodGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLCBmYWxsYmFja01zPzogbnVtYmVyKSA9PiB7XHJcbiAgICAvLyBDbGVhciBhbnkgcHJpb3IgYm91bmRhcnkgZmFsbGJhY2sgdGltZXJcclxuICAgIGlmICh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCkge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KVxyXG4gICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIHR0c1RleHRMZW5SZWYuY3VycmVudCA9IHRleHQ/Lmxlbmd0aCA/PyAwXHJcbiAgICB0dHNUZXh0UmVmLmN1cnJlbnQgPSB0ZXh0IHx8ICcnXHJcbiAgICAvLyBQcmVjb21wdXRlIHdvcmQgc3RhcnRzIGZvciBib3VuZGFyeS10by13b3JkIG1hcHBpbmdcclxuICAgIHR0c1dvcmRTdGFydHNSZWYuY3VycmVudCA9IFtdXHJcbiAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSAwXHJcbiAgICBpZiAodGV4dCkge1xyXG4gICAgICBjb25zdCByZWdleCA9IC9cXGJcXHdbXFx3J1xcLV0qXFxiL2dcclxuICAgICAgbGV0IG06IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcclxuICAgICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG0uaW5kZXggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQucHVzaChtLmluZGV4KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0ZXh0KSB7XHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICByZXR1cm4gKCkgPT4ge31cclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoIXN5bnRoKSByZXR1cm4gKCkgPT4ge31cclxuICAgICAgaWYgKHN5bnRoLnNwZWFraW5nKSBzeW50aC5jYW5jZWwoKVxyXG4gICAgICBjb25zdCB1dHRlciA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UodGV4dClcclxuICAgICAgLy8gS2VlcCBhIGNvbnNpc3RlbnQgcmF0ZSBmb3IgcHJlZGljdGFiaWxpdHlcclxuICAgICAgdXR0ZXIucmF0ZSA9IDFcclxuICAgICAgdXR0ZXIub25zdGFydCA9ICgpID0+IHtcclxuICAgICAgICBzZXRUdHNBY3RpdmUodHJ1ZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICB0dHNTdGFydFJlZi5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgICAgICBjaGFyUmF0ZVJlZi5jdXJyZW50ID0gMFxyXG4gICAgICAgIGVzdGltYXRlZFRvdGFsTXNSZWYuY3VycmVudCA9IGZhbGxiYWNrTXMgfHwgNTAwMFxyXG4gICAgICAgIC8vIEFsd2F5cyBydW4gYSB0aWNrOyBpZiBib3VuZGFyaWVzIHNob3cgdXAsIGl0IHdpbGwgYWRhcHQgdG8gdGltZS1iYXNlZCBlc3RpbWF0aW9uXHJcbiAgICAgICAgc3RhcnRQcm9ncmVzcyhlc3RpbWF0ZWRUb3RhbE1zUmVmLmN1cnJlbnQpXHJcbiAgICAgIH1cclxuICAgICAgLy8gVXNlIGJvdW5kYXJ5IGV2ZW50cyB0byByZWZsZWN0IHJlYWwtdGltZSBwcm9ncmVzc1xyXG4gICAgICB1dHRlci5vbmJvdW5kYXJ5ID0gKGV2OiBhbnkpID0+IHtcclxuICAgICAgICB0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAvLyBTdG9wIHRpbWVyIGZhbGxiYWNrOyBib3VuZGFyeSB3aWxsIGRyaXZlIHByb2dyZXNzXHJcbiAgICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgICBjb25zdCBpZHg6IG51bWJlciA9IHR5cGVvZiBldj8uY2hhckluZGV4ID09PSAnbnVtYmVyJyA/IGV2LmNoYXJJbmRleCA6IDBcclxuICAgICAgICBjb25zdCBzdGFydHMgPSB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnRcclxuICAgICAgICBjb25zdCB0b3RhbFdvcmRzID0gTWF0aC5tYXgoMSwgdHRzVG90YWxXb3Jkc1JlZi5jdXJyZW50KVxyXG4gICAgICAgIC8vIENvdW50IHdvcmRzIHdob3NlIHN0YXJ0IGluZGV4IGlzIDw9IGN1cnJlbnQgY2hhciBpbmRleFxyXG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gc3RhcnRzLmxlbmd0aFxyXG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMVxyXG4gICAgICAgICAgaWYgKHN0YXJ0c1ttaWRdIDw9IGlkeCkgbG93ID0gbWlkICsgMVxyXG4gICAgICAgICAgZWxzZSBoaWdoID0gbWlkXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNwb2tlbldvcmRzID0gTWF0aC5taW4obG93LCB0b3RhbFdvcmRzKVxyXG4gICAgICAgIGxldCBwY3RXb3JkcyA9IHNwb2tlbldvcmRzIC8gdG90YWxXb3Jkc1xyXG4gICAgICAgIGlmICh0dHNBY3RpdmVSZWYuY3VycmVudCAmJiBwY3RXb3JkcyA+PSAxKSBwY3RXb3JkcyA9IDAuOThcclxuICAgICAgICBzZXRQcm9ncmVzcyhwY3RXb3JkcylcclxuICAgICAgfVxyXG4gICAgICB1dHRlci5vbmVuZCA9ICgpID0+IHtcclxuICAgICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgIC8vIENvbXBsZXRlIHByb2dyZXNzIGFuZCBzdG9wIHRpbWVyOyBhdXRvLWFkdmFuY2UgZWZmZWN0IHdpbGwgcGljayB0aGlzIHVwXHJcbiAgICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgICBzZXRQcm9ncmVzcygxKVxyXG4gICAgICB9XHJcbiAgICAgIHN5bnRoLnNwZWFrKHV0dGVyKVxyXG5cclxuICAgICAgLy8gSWYgYm91bmRhcnkgZXZlbnRzIGFyZW7igJl0IHN1cHBvcnRlZCwgc3RhcnQgYSBmYWxsYmFjayBwcm9ncmVzcyB0aW1lciBhZnRlciBhIHNob3J0IGRlbGF5XHJcbiAgICAgIGlmIChmYWxsYmFja01zICYmIGZhbGxiYWNrTXMgPiAwKSB7XHJcbiAgICAgICAgdHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UHJvZ3Jlc3MoZmFsbGJhY2tNcylcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCA3MDApXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgc3ludGguY2FuY2VsKClcclxuICAgICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgICAgaWYgKHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY2FuY2VsXHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHJldHVybiAoKSA9PiB7fVxyXG4gICAgfVxyXG4gIH0sIFtzdGFydFByb2dyZXNzLCBzdG9wUHJvZ3Jlc3NdKVxyXG5cclxuICBjb25zdCBwbGF5U3RlcCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKHN0ZXA6IEFnZW50U3RlcCkgPT4ge1xyXG4gICAgICAvLyBFbnN1cmUgZnJlc2ggcHJvZ3Jlc3MvdHRzIHN0YXRlIGZvciB0aGlzIHN0ZXAgdG8gYXZvaWQgYXV0by1hZHZhbmNlIHJhY2VzXHJcbiAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgIHNldFByb2dyZXNzKDApXHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAnbmF2aWdhdGluZycgfSkpXHJcbiAgICAgIGF3YWl0IG5hdmlnYXRlVG8oc3RlcC5wYWdlKVxyXG4gICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGxheWluZycgfSkpXHJcbiAgICAgIC8vIFByZWZlciBUVFMtZHJpdmVuIHByb2dyZXNzIHZpYSBib3VuZGFyaWVzOyBmYWxsYmFjayB0byBhIHRpbWVyIGlmIGJvdW5kYXJpZXMgYXJlbuKAmXQgc3VwcG9ydGVkXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBjYW5jZWxTcGVlY2guY3VycmVudCA9IHNwZWFrVGV4dChzdGVwLnR0c1RleHQgfHwgc3RlcC50cmFuc2NyaXB0LCBzdGVwLnNwZWFrTXMgPz8gNTAwMClcclxuICAgICAgLy8gT3B0aW9uYWxseSB0cnkgYXVkaW8gYXMgYSBzdWJ0bGUgYmFja2dyb3VuZCBiZWVwIGlmIGF2YWlsYWJsZVxyXG4gICAgICAvLyBidXQgd2Ugbm8gbG9uZ2VyIHJlbHkgb24gYXVkaW8gZW5kIHRvIGFkdmFuY2VcclxuICAgICAgYXVkaW8ucGxheShzdGVwLmF1ZGlvVXJsKS5jYXRjaCgoKSA9PiB7fSlcclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIG5hdmlnYXRlVG8sIHNwZWFrVGV4dCwgc3RvcFByb2dyZXNzXVxyXG4gIClcclxuXHJcbiAgY29uc3Qgc3RhcnQgPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChjZmc/OiBQYXJ0aWFsPEFnZW50U2Vzc2lvbkNvbmZpZz4pID0+IHtcclxuICAgICAgLy8gQ2xlYW4gdXAgYW55IHByaW9yIHJ1biB0byBlbnN1cmUgZnJlc2ggc3RhdGVcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBhdWRpby5zdG9wKClcclxuICAgICAgfSBjYXRjaCB7fVxyXG4gICAgICBjYW5jZWxTcGVlY2guY3VycmVudD8uKClcclxuICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICBwZW5kaW5nTmF2LmN1cnJlbnQgPSBudWxsXHJcblxyXG4gICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAnZmV0Y2hpbmcnLCBlcnJvcjogdW5kZWZpbmVkIH0pKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHBsYW4gPSBhd2FpdCBmZXRjaEFnZW50UGxhbih7IC4uLmJhc2VDb25maWcsIC4uLmNmZyB9KVxyXG4gICAgICAgIGlmICghcGxhbi5zdGVwcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignTm8gc3RlcHMgcmV0dXJuZWQnKVxyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYW5kIGxldCBwbGF5U3RlcCBoYW5kbGUgbmF2aWdhdGlvbi9wcm9ncmVzczsgd2Ugb25seSBjYWxsIGl0IG9uY2UgaGVyZVxyXG4gICAgICAgIHNldFN0YXRlKHsgc3RhdHVzOiAnbmF2aWdhdGluZycsIGN1cnJlbnRTdGVwSW5kZXg6IDAsIHN0ZXBzOiBwbGFuLnN0ZXBzIH0pXHJcbiAgICAgICAgYXdhaXQgcGxheVN0ZXAocGxhbi5zdGVwc1swXSlcclxuICAgICAgfSBjYXRjaCAoZTogYW55KSB7XHJcbiAgICAgICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ2Vycm9yJywgZXJyb3I6IGU/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InIH0pKVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgW2F1ZGlvLCBiYXNlQ29uZmlnLCBwbGF5U3RlcCwgc3RvcFByb2dyZXNzXVxyXG4gIClcclxuXHJcbiAgY29uc3QgcGF1c2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBhdWRpby5wYXVzZSgpXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzeW50aCA9IHdpbmRvdy5zcGVlY2hTeW50aGVzaXNcclxuICAgICAgaWYgKHN5bnRoICYmIHN5bnRoLnNwZWFraW5nICYmICFzeW50aC5wYXVzZWQpIHN5bnRoLnBhdXNlKClcclxuICAgIH0gY2F0Y2gge31cclxuICAgIC8vIFBhdXNlIGZhbGxiYWNrIHRpbWVyIHByb2dyZXNzIGlmIHJ1bm5pbmdcclxuICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgaWYgKHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgICAgfVxyXG4gICAgICBpZiAocHJvZ3Jlc3NUaW1lci5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocHJvZ3Jlc3NUaW1lci5jdXJyZW50KVxyXG4gICAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ3BhdXNlZCcgfSkpXHJcbiAgfSwgW2F1ZGlvXSlcclxuXHJcbiAgY29uc3QgcmVzdW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgYXVkaW8ucmVzdW1lKClcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoc3ludGggJiYgc3ludGgucGF1c2VkKSBzeW50aC5yZXN1bWUoKVxyXG4gICAgfSBjYXRjaCB7fVxyXG4gICAgLy8gUmVzdW1lIGZhbGxiYWNrIHRpbWVyIHByb2dyZXNzIGlmIGJvdW5kYXJ5IG5vdCBhdmFpbGFibGVcclxuICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgaWYgKHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NQYXVzZUFjY3VtLmN1cnJlbnQgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnRcclxuICAgICAgICBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFwcm9ncmVzc1RpbWVyLmN1cnJlbnQgJiYgcHJvZ3Jlc3MgPCAxKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2tQcm9ncmVzcylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ3BsYXlpbmcnIH0pKVxyXG4gIH0sIFthdWRpbywgcHJvZ3Jlc3MsIHRpY2tQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBhdWRpby5zdG9wKClcclxuICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICBzZXRTdGF0ZSh7IHN0YXR1czogJ3N0b3BwZWQnLCBjdXJyZW50U3RlcEluZGV4OiAtMSwgc3RlcHM6IFtdIH0pXHJcbiAgfSwgW2F1ZGlvLCBzdG9wUHJvZ3Jlc3NdKVxyXG5cclxuICBjb25zdCBza2lwVG8gPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0ZXBzID0gc3RhdGUuc3RlcHNcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdGVwcy5sZW5ndGgpIHJldHVyblxyXG4gICAgICAvLyBTdG9wIGF1ZGlvIGFuZCBzcGVlY2ggYW5kIHJlc2V0IHByb2dyZXNzIGJlZm9yZSBzd2l0Y2hpbmdcclxuICAgICAgYXVkaW8uc3RvcCgpXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgY3VycmVudFN0ZXBJbmRleDogaW5kZXggfSkpXHJcbiAgICAgIGF3YWl0IHBsYXlTdGVwKHN0ZXBzW2luZGV4XSlcclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIHBsYXlTdGVwLCBzdGF0ZS5zdGVwcywgc3RvcFByb2dyZXNzXVxyXG4gIClcclxuXHJcbiAgLy8gQXV0by1hZHZhbmNlIHdoZW4gcHJvZ3Jlc3MgY29tcGxldGVzIEFORCBUVFMgKGlmIGFueSkgaGFzIGVuZGVkLlxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAncGxheWluZycgfHwgcHJvZ3Jlc3MgPCAxIHx8IHR0c0FjdGl2ZSkgcmV0dXJuXHJcbiAgICBpZiAoaXNBZHZhbmNpbmdSZWYuY3VycmVudCkgcmV0dXJuXHJcbiAgICBpc0FkdmFuY2luZ1JlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgOyhhc3luYyAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5jdXJyZW50U3RlcEluZGV4ICsgMVxyXG4gICAgICBpZiAobmV4dCA8IHN0YXRlLnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIGF3YWl0IHNraXBUbyhuZXh0KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEVuZCBvZiBwbGFuOiBiZWhhdmUgbGlrZSBTdG9wIGZvciBhIGZyZXNoLXJlYWR5IHN0YXRlXHJcbiAgICAgICAgc3RvcCgpXHJcbiAgICAgIH1cclxuICAgIH0pKCkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgfSlcclxuICB9LCBbcHJvZ3Jlc3MsIHR0c0FjdGl2ZSwgc3RhdGUuc3RhdHVzLCBzdGF0ZS5jdXJyZW50U3RlcEluZGV4LCBzdGF0ZS5zdGVwcy5sZW5ndGgsIHNraXBUbywgc3RvcF0pXHJcblxyXG4gIGNvbnN0IGN1cnJlbnRTdGVwID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICBpZiAoc3RhdGUuY3VycmVudFN0ZXBJbmRleCA8IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgIHJldHVybiBzdGF0ZS5zdGVwc1tzdGF0ZS5jdXJyZW50U3RlcEluZGV4XVxyXG4gIH0sIFtzdGF0ZS5jdXJyZW50U3RlcEluZGV4LCBzdGF0ZS5zdGVwc10pXHJcblxyXG4gIHJldHVybiB7IHN0YXRlLCBjdXJyZW50U3RlcCwgc3RhcnQsIHBhdXNlLCByZXN1bWUsIHN0b3AsIHNraXBUbywgcHJvZ3Jlc3MgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImZldGNoQWdlbnRQbGFuIiwidXNlQXVkaW9Db250cm9sbGVyIiwidXNlQWdlbnRDb250cm9sbGVyIiwicGRmUmVmIiwiYmFzZUNvbmZpZyIsIm9wdHMiLCJzdGF0ZSIsInNldFN0YXRlIiwic3RhdHVzIiwiY3VycmVudFN0ZXBJbmRleCIsInN0ZXBzIiwiYXVkaW8iLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwicHJvZ3Jlc3NUaW1lciIsInByb2dyZXNzU3RhcnQiLCJwcm9ncmVzc0R1cmF0aW9uIiwicHJvZ3Jlc3NQYXVzZWRBdCIsInByb2dyZXNzUGF1c2VBY2N1bSIsInBlbmRpbmdOYXYiLCJ0dHNBY3RpdmUiLCJzZXRUdHNBY3RpdmUiLCJ0dHNBY3RpdmVSZWYiLCJpc0FkdmFuY2luZ1JlZiIsInR0c1RleHRMZW5SZWYiLCJ0dHNCb3VuZGFyeVNlZW5SZWYiLCJ0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYiLCJ0dHNTdGFydFJlZiIsImVzdGltYXRlZFRvdGFsTXNSZWYiLCJjaGFyUmF0ZVJlZiIsInR0c1RleHRSZWYiLCJ0dHNXb3JkU3RhcnRzUmVmIiwidHRzVG90YWxXb3Jkc1JlZiIsIm5hdmlnYXRlVG8iLCJwYWdlIiwiZ28iLCJuYXZpZ2F0ZSIsImFwaSIsImN1cnJlbnQiLCJnb1RvUGFnZSIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInAiLCJmaW5hbGx5Iiwic3RvcFByb2dyZXNzIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0aWNrUHJvZ3Jlc3MiLCJub3ciLCJwZXJmb3JtYW5jZSIsInBhdXNlZCIsInBhdXNlQWRqIiwiZWxhcHNlZCIsInBjdCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdGFydFByb2dyZXNzIiwiZHVyYXRpb25NcyIsImNhbmNlbFNwZWVjaCIsInNwZWFrVGV4dCIsInRleHQiLCJmYWxsYmFja01zIiwid2luZG93IiwiY2xlYXJUaW1lb3V0IiwibGVuZ3RoIiwicmVnZXgiLCJtIiwiZXhlYyIsImluZGV4IiwicHVzaCIsInN5bnRoIiwic3BlZWNoU3ludGhlc2lzIiwic3BlYWtpbmciLCJjYW5jZWwiLCJ1dHRlciIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInJhdGUiLCJvbnN0YXJ0Iiwib25ib3VuZGFyeSIsImV2IiwiaWR4IiwiY2hhckluZGV4Iiwic3RhcnRzIiwidG90YWxXb3JkcyIsImxvdyIsImhpZ2giLCJtaWQiLCJzcG9rZW5Xb3JkcyIsInBjdFdvcmRzIiwib25lbmQiLCJzcGVhayIsInBsYXlTdGVwIiwic3RlcCIsInMiLCJ0dHNUZXh0IiwidHJhbnNjcmlwdCIsInNwZWFrTXMiLCJwbGF5IiwiYXVkaW9VcmwiLCJjYXRjaCIsInN0YXJ0IiwiY2ZnIiwic3RvcCIsImVycm9yIiwidW5kZWZpbmVkIiwicGxhbiIsIkVycm9yIiwiZSIsIm1lc3NhZ2UiLCJwYXVzZSIsInJlc3VtZSIsInNraXBUbyIsIm5leHQiLCJjdXJyZW50U3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/useAgentController.ts\n"));

/***/ })

});