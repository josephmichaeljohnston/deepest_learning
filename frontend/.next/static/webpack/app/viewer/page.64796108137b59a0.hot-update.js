"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/useAgentController.ts":
/*!*********************************************!*\
  !*** ./src/lib/agent/useAgentController.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgentController: function() { return /* binding */ useAgentController; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mockApi */ \"(app-pages-browser)/./src/lib/agent/mockApi.ts\");\n/* harmony import */ var _lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/audio/useAudioController */ \"(app-pages-browser)/./src/lib/audio/useAudioController.ts\");\n/* __next_internal_client_entry_do_not_use__ useAgentController auto */ \n\n\nfunction useAgentController(pdfRef, baseConfig, opts) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        status: \"idle\",\n        currentStepIndex: -1,\n        steps: []\n    });\n    const audio = (0,_lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__.useAudioController)();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const progressTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressPausedAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressPauseAccum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pendingNav = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [ttsActive, setTtsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ttsActiveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isAdvancingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsTextLenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsBoundarySeenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsBoundaryFallbackTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ttsStartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const estimatedTotalMsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const charRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsTextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const ttsWordStartsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const ttsTotalWordsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const userSkipRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const postSlidePromptRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const nextAfterPromptRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pendingNextIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const navigateTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (page)=>{\n        const go = async ()=>{\n            if (opts === null || opts === void 0 ? void 0 : opts.navigate) {\n                opts.navigate(page);\n            } else {\n                const api = pdfRef.current;\n                api === null || api === void 0 ? void 0 : api.goToPage(page);\n            }\n            await new Promise((r)=>setTimeout(r, 150));\n        };\n        const p = go().finally(()=>{\n            if (pendingNav.current === p) pendingNav.current = null;\n        });\n        pendingNav.current = p;\n        await p;\n    }, [\n        opts,\n        pdfRef\n    ]);\n    const stopProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressTimer.current) {\n            cancelAnimationFrame(progressTimer.current);\n            progressTimer.current = null;\n        }\n    }, []);\n    const tickProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const now = performance.now();\n        const paused = progressPausedAt.current;\n        const pauseAdj = progressPauseAccum.current + (paused ? now - paused : 0);\n        const elapsed = now - progressStart.current - pauseAdj;\n        let pct = Math.min(1, elapsed / Math.max(1, progressDuration.current));\n        if (ttsActiveRef.current && pct >= 1) pct = 0.98;\n        setProgress(pct);\n        if (pct < 1 || ttsActiveRef.current) {\n            progressTimer.current = requestAnimationFrame(tickProgress);\n        } else {\n            progressTimer.current = null;\n        }\n    }, []);\n    const startProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((durationMs)=>{\n        stopProgress();\n        setProgress(0);\n        progressDuration.current = Math.max(1000, durationMs);\n        progressStart.current = performance.now();\n        progressPausedAt.current = null;\n        progressPauseAccum.current = 0;\n        progressTimer.current = requestAnimationFrame(tickProgress);\n    }, [\n        stopProgress,\n        tickProgress\n    ]);\n    const cancelSpeech = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const speakText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text, fallbackMs)=>{\n        // Clear any prior boundary fallback timer\n        if (ttsBoundaryFallbackTimerRef.current) {\n            window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n            ttsBoundaryFallbackTimerRef.current = null;\n        }\n        ttsBoundarySeenRef.current = false;\n        var _text_length;\n        ttsTextLenRef.current = (_text_length = text === null || text === void 0 ? void 0 : text.length) !== null && _text_length !== void 0 ? _text_length : 0;\n        ttsTextRef.current = text || \"\";\n        // Precompute word starts for boundary-to-word mapping\n        ttsWordStartsRef.current = [];\n        ttsTotalWordsRef.current = 0;\n        if (text) {\n            const regex = /\\b\\w[\\w'\\-]*\\b/g;\n            let m;\n            while((m = regex.exec(text)) !== null){\n                if (typeof m.index === \"number\") {\n                    ttsWordStartsRef.current.push(m.index);\n                }\n            }\n            ttsTotalWordsRef.current = ttsWordStartsRef.current.length;\n        }\n        if (!text) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n        try {\n            const synth = window.speechSynthesis;\n            if (!synth) return ()=>{};\n            if (synth.speaking) synth.cancel();\n            const utter = new SpeechSynthesisUtterance(text);\n            // Keep a consistent rate for predictability\n            utter.rate = 1;\n            utter.onstart = ()=>{\n                setTtsActive(true);\n                ttsActiveRef.current = true;\n                // Clear user-initiated skip suppression once the new step starts speaking\n                userSkipRef.current = false;\n                ttsStartRef.current = performance.now();\n                charRateRef.current = 0;\n                estimatedTotalMsRef.current = fallbackMs || 5000;\n                // Always run a tick; if boundaries show up, it will adapt to time-based estimation\n                startProgress(estimatedTotalMsRef.current);\n            };\n            // Use boundary events to reflect real-time progress\n            utter.onboundary = (ev)=>{\n                ttsBoundarySeenRef.current = true;\n                // Stop timer fallback; boundary will drive progress\n                stopProgress();\n                const idx = typeof (ev === null || ev === void 0 ? void 0 : ev.charIndex) === \"number\" ? ev.charIndex : 0;\n                const starts = ttsWordStartsRef.current;\n                const totalWords = Math.max(1, ttsTotalWordsRef.current);\n                // Count words whose start index is <= current char index\n                let low = 0, high = starts.length;\n                while(low < high){\n                    const mid = low + high >> 1;\n                    if (starts[mid] <= idx) low = mid + 1;\n                    else high = mid;\n                }\n                const spokenWords = Math.min(low, totalWords);\n                let pctWords = spokenWords / totalWords;\n                if (ttsActiveRef.current && pctWords >= 1) pctWords = 0.98;\n                setProgress(pctWords);\n            };\n            utter.onend = ()=>{\n                setTtsActive(false);\n                ttsActiveRef.current = false;\n                // Complete progress and stop timer; auto-advance effect will pick this up\n                stopProgress();\n                setProgress(1);\n            };\n            synth.speak(utter);\n            // If boundary events aren’t supported, start a fallback progress timer after a short delay\n            if (fallbackMs && fallbackMs > 0) {\n                ttsBoundaryFallbackTimerRef.current = window.setTimeout(()=>{\n                    if (!ttsBoundarySeenRef.current) {\n                        startProgress(fallbackMs);\n                    }\n                }, 700);\n            }\n            const cancel = ()=>{\n                try {\n                    synth.cancel();\n                } finally{\n                    setTtsActive(false);\n                    ttsActiveRef.current = false;\n                    if (ttsBoundaryFallbackTimerRef.current) {\n                        window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n                        ttsBoundaryFallbackTimerRef.current = null;\n                    }\n                }\n            };\n            return cancel;\n        } catch (e) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n    }, [\n        startProgress,\n        stopProgress\n    ]);\n    const playStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (step)=>{\n        var // Prefer TTS-driven progress via boundaries; fallback to a timer if boundaries aren’t supported\n        _cancelSpeech_current;\n        // Ensure fresh progress/tts state for this step to avoid auto-advance races\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        setState((s)=>({\n                ...s,\n                status: \"navigating\"\n            }));\n        await navigateTo(step.page);\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        var _step_speakMs;\n        cancelSpeech.current = speakText(step.ttsText || step.transcript, (_step_speakMs = step.speakMs) !== null && _step_speakMs !== void 0 ? _step_speakMs : 5000);\n        // Optionally try audio as a subtle background beep if available\n        // but we no longer rely on audio end to advance\n        audio.play(step.audioUrl).catch(()=>{});\n    }, [\n        audio,\n        navigateTo,\n        speakText,\n        stopProgress\n    ]);\n    const start = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cfg)=>{\n        var _cancelSpeech_current;\n        // Clean up any prior run to ensure fresh state\n        try {\n            audio.stop();\n        } catch (e) {}\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        isAdvancingRef.current = false;\n        pendingNav.current = null;\n        setState((s)=>({\n                ...s,\n                status: \"fetching\",\n                error: undefined\n            }));\n        try {\n            const plan = await (0,_mockApi__WEBPACK_IMPORTED_MODULE_1__.fetchAgentPlan)({\n                ...baseConfig,\n                ...cfg\n            });\n            if (!plan.steps.length) throw new Error(\"No steps returned\");\n            // Initialize and let playStep handle navigation/progress; we only call it once here\n            setState({\n                status: \"navigating\",\n                currentStepIndex: 0,\n                steps: plan.steps\n            });\n            await playStep(plan.steps[0]);\n        } catch (e) {\n            setState((s)=>({\n                    ...s,\n                    status: \"error\",\n                    error: (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\"\n                }));\n        }\n    }, [\n        audio,\n        baseConfig,\n        playStep,\n        stopProgress\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.pause();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.speaking && !synth.paused) synth.pause();\n        } catch (e) {}\n        // Pause fallback timer progress if running\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current == null) {\n                progressPausedAt.current = performance.now();\n            }\n            if (progressTimer.current) {\n                cancelAnimationFrame(progressTimer.current);\n                progressTimer.current = null;\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"paused\"\n            }));\n    }, [\n        audio\n    ]);\n    const skipTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        var _cancelSpeech_current;\n        const steps = state.steps;\n        if (index < 0 || index >= steps.length) return;\n        // Stop audio and speech and reset progress before switching\n        audio.stop();\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setState((s)=>({\n                ...s,\n                currentStepIndex: index\n            }));\n        await playStep(steps[index]);\n    }, [\n        audio,\n        playStep,\n        state.steps,\n        stopProgress\n    ]);\n    const resume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.resume();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.paused) synth.resume();\n        } catch (e) {}\n        // Resume fallback timer progress if boundary not available\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current != null) {\n                progressPauseAccum.current += performance.now() - progressPausedAt.current;\n                progressPausedAt.current = null;\n            }\n            if (!progressTimer.current && progress < 1) {\n                progressTimer.current = requestAnimationFrame(tickProgress);\n            }\n        }\n        // If a post-slide prompt was shown, continue to the next step\n        if (nextAfterPromptRef.current && pendingNextIndexRef.current != null) {\n            const idx = pendingNextIndexRef.current;\n            nextAfterPromptRef.current = false;\n            pendingNextIndexRef.current = null;\n            // Switch to next step\n            skipTo(idx);\n            return;\n        }\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n    }, [\n        audio,\n        progress,\n        tickProgress,\n        skipTo\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cancelSpeech_current;\n        audio.stop();\n        stopProgress();\n        setProgress(0);\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        setState({\n            status: \"stopped\",\n            currentStepIndex: -1,\n            steps: []\n        });\n    }, [\n        audio,\n        stopProgress\n    ]);\n    // Public user-initiated jump: prevent auto-advance from chaining over the user’s selection\n    const jumpTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        userSkipRef.current = true;\n        await skipTo(index);\n    }, [\n        skipTo\n    ]);\n    // Auto-advance when progress completes AND TTS (if any) has ended.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        console.log(\"[AutoAdvance] Checking conditions:\", {\n            status: state.status,\n            progress,\n            ttsActive,\n            userSkip: userSkipRef.current,\n            isAdvancing: isAdvancingRef.current\n        });\n        if (state.status !== \"playing\" || progress < 1 || ttsActive) return;\n        // If user just jumped, do not auto-advance from the old step completion\n        if (userSkipRef.current) return;\n        if (isAdvancingRef.current) return;\n        isAdvancingRef.current = true;\n        console.log(\"[AutoAdvance] TRIGGERING - Progress complete and TTS ended\");\n        (async ()=>{\n            // After each slide narration finishes, pause and prompt the user\n            console.log(\"[AutoAdvance] Pausing agent...\");\n            try {\n                pause();\n            } catch (e) {\n                console.error(\"[AutoAdvance] Pause error:\", e);\n            }\n            console.log('[AutoAdvance] Calling postSlidePromptRef.current?.(\"Do you understand?\")');\n            console.log(\"[AutoAdvance] postSlidePromptRef.current exists:\", !!postSlidePromptRef.current);\n            try {\n                var _postSlidePromptRef_current;\n                (_postSlidePromptRef_current = postSlidePromptRef.current) === null || _postSlidePromptRef_current === void 0 ? void 0 : _postSlidePromptRef_current.call(postSlidePromptRef, \"Do you understand?\");\n            } catch (e) {\n                console.error(\"[AutoAdvance] Prompt callback error:\", e);\n            }\n            const next = state.currentStepIndex + 1;\n            console.log(\"[AutoAdvance] Next index:\", next, \"Total steps:\", state.steps.length);\n            if (next < state.steps.length) {\n                nextAfterPromptRef.current = true;\n                pendingNextIndexRef.current = next;\n            } else {\n                // End of plan: behave like Stop for a fresh-ready state\n                stop();\n            }\n        })().finally(()=>{\n            isAdvancingRef.current = false;\n        });\n    }, [\n        progress,\n        ttsActive,\n        state.status,\n        state.currentStepIndex,\n        state.steps.length,\n        pause,\n        stop\n    ]);\n    // Hook up external prompt handler from opts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _opts_onPrompt;\n        postSlidePromptRef.current = (_opts_onPrompt = opts === null || opts === void 0 ? void 0 : opts.onPrompt) !== null && _opts_onPrompt !== void 0 ? _opts_onPrompt : null;\n        return ()=>{\n            postSlidePromptRef.current = null;\n        };\n    }, [\n        opts === null || opts === void 0 ? void 0 : opts.onPrompt\n    ]);\n    const currentStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (state.currentStepIndex < 0) return undefined;\n        return state.steps[state.currentStepIndex];\n    }, [\n        state.currentStepIndex,\n        state.steps\n    ]);\n    const requestPrompt = (message)=>{\n        var _postSlidePromptRef_current;\n        (_postSlidePromptRef_current = postSlidePromptRef.current) === null || _postSlidePromptRef_current === void 0 ? void 0 : _postSlidePromptRef_current.call(postSlidePromptRef, message);\n    };\n    return {\n        state,\n        currentStep,\n        start,\n        pause,\n        resume,\n        stop,\n        skipTo,\n        jumpTo,\n        progress,\n        requestPrompt\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dFQUV5RTtBQUUvQjtBQUV5QjtBQWtCNUQsU0FBU08sbUJBQ2RDLE1BQXVDLEVBQ3ZDQyxVQUE4QixFQUM5QkMsSUFBbUY7SUFFbkYsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdSLCtDQUFRQSxDQUF1QjtRQUN2RFMsUUFBUTtRQUNSQyxrQkFBa0IsQ0FBQztRQUNuQkMsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNQyxRQUFRVixpRkFBa0JBO0lBQ2hDLE1BQU0sQ0FBQ1csVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNZSxnQkFBZ0JoQiw2Q0FBTUEsQ0FBZ0I7SUFDNUMsTUFBTWlCLGdCQUFnQmpCLDZDQUFNQSxDQUFTO0lBQ3JDLE1BQU1rQixtQkFBbUJsQiw2Q0FBTUEsQ0FBUztJQUN4QyxNQUFNbUIsbUJBQW1CbkIsNkNBQU1BLENBQWdCO0lBQy9DLE1BQU1vQixxQkFBcUJwQiw2Q0FBTUEsQ0FBUztJQUMxQyxNQUFNcUIsYUFBYXJCLDZDQUFNQSxDQUF1QjtJQUNoRCxNQUFNLENBQUNzQixXQUFXQyxhQUFhLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNdUIsZUFBZXhCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU15QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNMEIsZ0JBQWdCMUIsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTJCLHFCQUFxQjNCLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU00Qiw4QkFBOEI1Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUQsTUFBTTZCLGNBQWM3Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUMsTUFBTThCLHNCQUFzQjlCLDZDQUFNQSxDQUFTO0lBQzNDLE1BQU0rQixjQUFjL0IsNkNBQU1BLENBQVM7SUFDbkMsTUFBTWdDLGFBQWFoQyw2Q0FBTUEsQ0FBUztJQUNsQyxN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QjtRQUFVUTtRQUFXZCxNQUFNRSxNQUFNO1FBQUVGLE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLLENBQUM0RCxNQUFNO1FBQUU2QztRQUFPUDtLQUFLO0lBRS9GLDRDQUE0QztJQUM1Q2hILGdEQUFTQSxDQUFDO1lBQ3FCUztRQUE3QjZCLG1CQUFtQlEsT0FBTyxHQUFHckMsQ0FBQUEsaUJBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXVILFFBQVEsY0FBZHZILDRCQUFBQSxpQkFBa0I7UUFDL0MsT0FBTztZQUFRNkIsbUJBQW1CUSxPQUFPLEdBQUc7UUFBSztJQUNuRCxHQUFHO1FBQUNyQyxpQkFBQUEsMkJBQUFBLEtBQU11SCxRQUFRO0tBQUM7SUFFbkIsTUFBTUMsY0FBY2hJLDhDQUFPQSxDQUFDO1FBQzFCLElBQUlTLE1BQU1HLGdCQUFnQixHQUFHLEdBQUcsT0FBT3FHO1FBQ3ZDLE9BQU94RyxNQUFNSSxLQUFLLENBQUNKLE1BQU1HLGdCQUFnQixDQUFDO0lBQzVDLEdBQUc7UUFBQ0gsTUFBTUcsZ0JBQWdCO1FBQUVILE1BQU1JLEtBQUs7S0FBQztJQUV4QyxNQUFNb0gsZ0JBQWdCLENBQUNaO1lBQ3JCaEY7U0FBQUEsOEJBQUFBLG1CQUFtQlEsT0FBTyxjQUExQlIsa0RBQUFBLGlDQUFBQSxvQkFBNkJnRjtJQUMvQjtJQUVBLE9BQU87UUFBRTVHO1FBQU91SDtRQUFhbkI7UUFBT1M7UUFBT0U7UUFBUVQ7UUFBTVE7UUFBUUU7UUFBUTFHO1FBQVVrSDtJQUFjO0FBQ25HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzPzRlMjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXHJcbmltcG9ydCB0eXBlIHsgUGRmQ2Fyb3VzZWxSZWYgfSBmcm9tICdAL2NvbXBvbmVudHMvUGRmQ2Fyb3VzZWwnXHJcbmltcG9ydCB7IGZldGNoQWdlbnRQbGFuIH0gZnJvbSAnLi9tb2NrQXBpJ1xyXG5pbXBvcnQgdHlwZSB7IEFnZW50Q29udHJvbGxlclN0YXRlLCBBZ2VudFNlc3Npb25Db25maWcsIEFnZW50U3RlcCB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IHVzZUF1ZGlvQ29udHJvbGxlciB9IGZyb20gJ0AvbGliL2F1ZGlvL3VzZUF1ZGlvQ29udHJvbGxlcidcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWdlbnRDb250cm9sbGVyQXBpIHtcclxuICBzdGF0ZTogQWdlbnRDb250cm9sbGVyU3RhdGVcclxuICBjdXJyZW50U3RlcD86IEFnZW50U3RlcFxyXG4gIHN0YXJ0OiAoY2ZnPzogUGFydGlhbDxBZ2VudFNlc3Npb25Db25maWc+KSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgcGF1c2U6ICgpID0+IHZvaWRcclxuICByZXN1bWU6ICgpID0+IHZvaWRcclxuICBzdG9wOiAoKSA9PiB2b2lkXHJcbiAgc2tpcFRvOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIC8vIFVzZXItaW5pdGlhdGVkIGp1bXAgdGhhdCBzdXBwcmVzc2VzIGF1dG8tYWR2YW5jZSBkdXJpbmcgdHJhbnNpdGlvblxyXG4gIGp1bXBUbzogKGluZGV4OiBudW1iZXIpID0+IFByb21pc2U8dm9pZD5cclxuICAvLyBTaW11bGF0ZWQgcHJvZ3Jlc3Mgb2YgY3VycmVudCBzdGVwOiAwLi4xXHJcbiAgcHJvZ3Jlc3M6IG51bWJlclxyXG4gIC8vIFBvc3Qtc2xpZGUgcHJvbXB0IGNvbnRyb2xcclxuICByZXF1ZXN0UHJvbXB0OiAobWVzc2FnZT86IHN0cmluZykgPT4gdm9pZFxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQWdlbnRDb250cm9sbGVyKFxyXG4gIHBkZlJlZjogUmVhY3QuUmVmT2JqZWN0PFBkZkNhcm91c2VsUmVmPixcclxuICBiYXNlQ29uZmlnOiBBZ2VudFNlc3Npb25Db25maWcsXHJcbiAgb3B0cz86IHsgbmF2aWdhdGU/OiAocGFnZTogbnVtYmVyKSA9PiB2b2lkOyBvblByb21wdD86IChtZXNzYWdlPzogc3RyaW5nKSA9PiB2b2lkIH1cclxuKTogQWdlbnRDb250cm9sbGVyQXBpIHtcclxuICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlPEFnZW50Q29udHJvbGxlclN0YXRlPih7XHJcbiAgICBzdGF0dXM6ICdpZGxlJyxcclxuICAgIGN1cnJlbnRTdGVwSW5kZXg6IC0xLFxyXG4gICAgc3RlcHM6IFtdLFxyXG4gIH0pXHJcbiAgY29uc3QgYXVkaW8gPSB1c2VBdWRpb0NvbnRyb2xsZXIoKVxyXG4gIGNvbnN0IFtwcm9ncmVzcywgc2V0UHJvZ3Jlc3NdID0gdXNlU3RhdGUoMClcclxuICBjb25zdCBwcm9ncmVzc1RpbWVyID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgcHJvZ3Jlc3NTdGFydCA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgcHJvZ3Jlc3NEdXJhdGlvbiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgcHJvZ3Jlc3NQYXVzZWRBdCA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHByb2dyZXNzUGF1c2VBY2N1bSA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgcGVuZGluZ05hdiA9IHVzZVJlZjxQcm9taXNlPHZvaWQ+IHwgbnVsbD4obnVsbClcclxuICBjb25zdCBbdHRzQWN0aXZlLCBzZXRUdHNBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpXHJcbiAgY29uc3QgdHRzQWN0aXZlUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IGlzQWR2YW5jaW5nUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IHR0c1RleHRMZW5SZWYgPSB1c2VSZWYoMClcclxuICBjb25zdCB0dHNCb3VuZGFyeVNlZW5SZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgdHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgdHRzU3RhcnRSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBlc3RpbWF0ZWRUb3RhbE1zUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBjaGFyUmF0ZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgdHRzVGV4dFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKVxyXG4gIGNvbnN0IHR0c1dvcmRTdGFydHNSZWYgPSB1c2VSZWY8bnVtYmVyW10+KFtdKVxyXG4gIGNvbnN0IHR0c1RvdGFsV29yZHNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IHVzZXJTa2lwUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IHBvc3RTbGlkZVByb21wdFJlZiA9IHVzZVJlZjwoKG1zZz86IHN0cmluZykgPT4gdm9pZCkgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IG5leHRBZnRlclByb21wdFJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCBwZW5kaW5nTmV4dEluZGV4UmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcblxyXG4gIGNvbnN0IG5hdmlnYXRlVG8gPSB1c2VDYWxsYmFjayhhc3luYyAocGFnZTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBnbyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgaWYgKG9wdHM/Lm5hdmlnYXRlKSB7XHJcbiAgICAgICAgb3B0cy5uYXZpZ2F0ZShwYWdlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGFwaSA9IHBkZlJlZi5jdXJyZW50XHJcbiAgICAgICAgYXBpPy5nb1RvUGFnZShwYWdlKVxyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIDE1MCkpXHJcbiAgICB9XHJcbiAgICBjb25zdCBwID0gZ28oKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgaWYgKHBlbmRpbmdOYXYuY3VycmVudCA9PT0gcCkgcGVuZGluZ05hdi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfSlcclxuICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IHBcclxuICAgIGF3YWl0IHBcclxuICB9LCBbb3B0cywgcGRmUmVmXSlcclxuXHJcbiAgY29uc3Qgc3RvcFByb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgaWYgKHByb2dyZXNzVGltZXIuY3VycmVudCkge1xyXG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVyLmN1cnJlbnQpXHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3QgdGlja1Byb2dyZXNzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgIGNvbnN0IHBhdXNlZCA9IHByb2dyZXNzUGF1c2VkQXQuY3VycmVudFxyXG4gICAgY29uc3QgcGF1c2VBZGogPSBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCArIChwYXVzZWQgPyBub3cgLSBwYXVzZWQgOiAwKVxyXG4gICAgY29uc3QgZWxhcHNlZCA9IG5vdyAtIHByb2dyZXNzU3RhcnQuY3VycmVudCAtIHBhdXNlQWRqXHJcbiAgICBsZXQgcGN0ID0gTWF0aC5taW4oMSwgZWxhcHNlZCAvIE1hdGgubWF4KDEsIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCkpXHJcbiAgICBpZiAodHRzQWN0aXZlUmVmLmN1cnJlbnQgJiYgcGN0ID49IDEpIHBjdCA9IDAuOThcclxuICAgIHNldFByb2dyZXNzKHBjdClcclxuICAgIGlmIChwY3QgPCAxIHx8IHR0c0FjdGl2ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrUHJvZ3Jlc3MpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSBudWxsXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcblxyXG4gIGNvbnN0IHN0YXJ0UHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoZHVyYXRpb25NczogbnVtYmVyKSA9PiB7XHJcbiAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgIHByb2dyZXNzRHVyYXRpb24uY3VycmVudCA9IE1hdGgubWF4KDEwMDAsIGR1cmF0aW9uTXMpXHJcbiAgICBwcm9ncmVzc1N0YXJ0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgcHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID0gbnVsbFxyXG4gICAgcHJvZ3Jlc3NQYXVzZUFjY3VtLmN1cnJlbnQgPSAwXHJcbiAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1Byb2dyZXNzKVxyXG4gIH0sIFtzdG9wUHJvZ3Jlc3MsIHRpY2tQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IGNhbmNlbFNwZWVjaCA9IHVzZVJlZjwoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKVxyXG5cclxuICBjb25zdCBzcGVha1RleHQgPSB1c2VDYWxsYmFjaygodGV4dDogc3RyaW5nIHwgdW5kZWZpbmVkLCBmYWxsYmFja01zPzogbnVtYmVyKSA9PiB7XHJcbiAgICAvLyBDbGVhciBhbnkgcHJpb3IgYm91bmRhcnkgZmFsbGJhY2sgdGltZXJcclxuICAgIGlmICh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCkge1xyXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KVxyXG4gICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIHR0c1RleHRMZW5SZWYuY3VycmVudCA9IHRleHQ/Lmxlbmd0aCA/PyAwXHJcbiAgICB0dHNUZXh0UmVmLmN1cnJlbnQgPSB0ZXh0IHx8ICcnXHJcbiAgICAvLyBQcmVjb21wdXRlIHdvcmQgc3RhcnRzIGZvciBib3VuZGFyeS10by13b3JkIG1hcHBpbmdcclxuICAgIHR0c1dvcmRTdGFydHNSZWYuY3VycmVudCA9IFtdXHJcbiAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSAwXHJcbiAgICBpZiAodGV4dCkge1xyXG4gICAgICBjb25zdCByZWdleCA9IC9cXGJcXHdbXFx3J1xcLV0qXFxiL2dcclxuICAgICAgbGV0IG06IFJlZ0V4cEV4ZWNBcnJheSB8IG51bGxcclxuICAgICAgd2hpbGUgKChtID0gcmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG0uaW5kZXggPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQucHVzaChtLmluZGV4KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQgPSB0dHNXb3JkU3RhcnRzUmVmLmN1cnJlbnQubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0ZXh0KSB7XHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICByZXR1cm4gKCkgPT4ge31cclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoIXN5bnRoKSByZXR1cm4gKCkgPT4ge31cclxuICAgICAgaWYgKHN5bnRoLnNwZWFraW5nKSBzeW50aC5jYW5jZWwoKVxyXG4gICAgICBjb25zdCB1dHRlciA9IG5ldyBTcGVlY2hTeW50aGVzaXNVdHRlcmFuY2UodGV4dClcclxuICAgICAgLy8gS2VlcCBhIGNvbnNpc3RlbnQgcmF0ZSBmb3IgcHJlZGljdGFiaWxpdHlcclxuICAgICAgdXR0ZXIucmF0ZSA9IDFcclxuICAgICAgdXR0ZXIub25zdGFydCA9ICgpID0+IHtcclxuICAgICAgICBzZXRUdHNBY3RpdmUodHJ1ZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IHRydWVcclxuICAgICAgICAvLyBDbGVhciB1c2VyLWluaXRpYXRlZCBza2lwIHN1cHByZXNzaW9uIG9uY2UgdGhlIG5ldyBzdGVwIHN0YXJ0cyBzcGVha2luZ1xyXG4gICAgICAgIHVzZXJTa2lwUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICAgIHR0c1N0YXJ0UmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgICAgIGNoYXJSYXRlUmVmLmN1cnJlbnQgPSAwXHJcbiAgICAgICAgZXN0aW1hdGVkVG90YWxNc1JlZi5jdXJyZW50ID0gZmFsbGJhY2tNcyB8fCA1MDAwXHJcbiAgICAgICAgLy8gQWx3YXlzIHJ1biBhIHRpY2s7IGlmIGJvdW5kYXJpZXMgc2hvdyB1cCwgaXQgd2lsbCBhZGFwdCB0byB0aW1lLWJhc2VkIGVzdGltYXRpb25cclxuICAgICAgICBzdGFydFByb2dyZXNzKGVzdGltYXRlZFRvdGFsTXNSZWYuY3VycmVudClcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgYm91bmRhcnkgZXZlbnRzIHRvIHJlZmxlY3QgcmVhbC10aW1lIHByb2dyZXNzXHJcbiAgICAgIHV0dGVyLm9uYm91bmRhcnkgPSAoZXY6IGFueSkgPT4ge1xyXG4gICAgICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIC8vIFN0b3AgdGltZXIgZmFsbGJhY2s7IGJvdW5kYXJ5IHdpbGwgZHJpdmUgcHJvZ3Jlc3NcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIGNvbnN0IGlkeDogbnVtYmVyID0gdHlwZW9mIGV2Py5jaGFySW5kZXggPT09ICdudW1iZXInID8gZXYuY2hhckluZGV4IDogMFxyXG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IHR0c1dvcmRTdGFydHNSZWYuY3VycmVudFxyXG4gICAgICAgIGNvbnN0IHRvdGFsV29yZHMgPSBNYXRoLm1heCgxLCB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgLy8gQ291bnQgd29yZHMgd2hvc2Ugc3RhcnQgaW5kZXggaXMgPD0gY3VycmVudCBjaGFyIGluZGV4XHJcbiAgICAgICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBzdGFydHMubGVuZ3RoXHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxXHJcbiAgICAgICAgICBpZiAoc3RhcnRzW21pZF0gPD0gaWR4KSBsb3cgPSBtaWQgKyAxXHJcbiAgICAgICAgICBlbHNlIGhpZ2ggPSBtaWRcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3Bva2VuV29yZHMgPSBNYXRoLm1pbihsb3csIHRvdGFsV29yZHMpXHJcbiAgICAgICAgbGV0IHBjdFdvcmRzID0gc3Bva2VuV29yZHMgLyB0b3RhbFdvcmRzXHJcbiAgICAgICAgaWYgKHR0c0FjdGl2ZVJlZi5jdXJyZW50ICYmIHBjdFdvcmRzID49IDEpIHBjdFdvcmRzID0gMC45OFxyXG4gICAgICAgIHNldFByb2dyZXNzKHBjdFdvcmRzKVxyXG4gICAgICB9XHJcbiAgICAgIHV0dGVyLm9uZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgLy8gQ29tcGxldGUgcHJvZ3Jlc3MgYW5kIHN0b3AgdGltZXI7IGF1dG8tYWR2YW5jZSBlZmZlY3Qgd2lsbCBwaWNrIHRoaXMgdXBcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIHNldFByb2dyZXNzKDEpXHJcbiAgICAgIH1cclxuICAgICAgc3ludGguc3BlYWsodXR0ZXIpXHJcblxyXG4gICAgICAvLyBJZiBib3VuZGFyeSBldmVudHMgYXJlbuKAmXQgc3VwcG9ydGVkLCBzdGFydCBhIGZhbGxiYWNrIHByb2dyZXNzIHRpbWVyIGFmdGVyIGEgc2hvcnQgZGVsYXlcclxuICAgICAgaWYgKGZhbGxiYWNrTXMgJiYgZmFsbGJhY2tNcyA+IDApIHtcclxuICAgICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgc3RhcnRQcm9ncmVzcyhmYWxsYmFja01zKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDcwMClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzeW50aC5jYW5jZWwoKVxyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBpZiAodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudClcclxuICAgICAgICAgICAgdHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYW5jZWxcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgcmV0dXJuICgpID0+IHt9XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0UHJvZ3Jlc3MsIHN0b3BQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHBsYXlTdGVwID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAoc3RlcDogQWdlbnRTdGVwKSA9PiB7XHJcbiAgICAgIC8vIEVuc3VyZSBmcmVzaCBwcm9ncmVzcy90dHMgc3RhdGUgZm9yIHRoaXMgc3RlcCB0byBhdm9pZCBhdXRvLWFkdmFuY2UgcmFjZXNcclxuICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICduYXZpZ2F0aW5nJyB9KSlcclxuICAgICAgYXdhaXQgbmF2aWdhdGVUbyhzdGVwLnBhZ2UpXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwbGF5aW5nJyB9KSlcclxuICAgICAgLy8gUHJlZmVyIFRUUy1kcml2ZW4gcHJvZ3Jlc3MgdmlhIGJvdW5kYXJpZXM7IGZhbGxiYWNrIHRvIGEgdGltZXIgaWYgYm91bmRhcmllcyBhcmVu4oCZdCBzdXBwb3J0ZWRcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50ID0gc3BlYWtUZXh0KHN0ZXAudHRzVGV4dCB8fCBzdGVwLnRyYW5zY3JpcHQsIHN0ZXAuc3BlYWtNcyA/PyA1MDAwKVxyXG4gICAgICAvLyBPcHRpb25hbGx5IHRyeSBhdWRpbyBhcyBhIHN1YnRsZSBiYWNrZ3JvdW5kIGJlZXAgaWYgYXZhaWxhYmxlXHJcbiAgICAgIC8vIGJ1dCB3ZSBubyBsb25nZXIgcmVseSBvbiBhdWRpbyBlbmQgdG8gYWR2YW5jZVxyXG4gICAgICBhdWRpby5wbGF5KHN0ZXAuYXVkaW9VcmwpLmNhdGNoKCgpID0+IHt9KVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgbmF2aWdhdGVUbywgc3BlYWtUZXh0LCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBzdGFydCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGNmZz86IFBhcnRpYWw8QWdlbnRTZXNzaW9uQ29uZmlnPikgPT4ge1xyXG4gICAgICAvLyBDbGVhbiB1cCBhbnkgcHJpb3IgcnVuIHRvIGVuc3VyZSBmcmVzaCBzdGF0ZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF1ZGlvLnN0b3AoKVxyXG4gICAgICB9IGNhdGNoIHt9XHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgaXNBZHZhbmNpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IG51bGxcclxuXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdmZXRjaGluZycsIGVycm9yOiB1bmRlZmluZWQgfSkpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGxhbiA9IGF3YWl0IGZldGNoQWdlbnRQbGFuKHsgLi4uYmFzZUNvbmZpZywgLi4uY2ZnIH0pXHJcbiAgICAgICAgaWYgKCFwbGFuLnN0ZXBzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdObyBzdGVwcyByZXR1cm5lZCcpXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbmQgbGV0IHBsYXlTdGVwIGhhbmRsZSBuYXZpZ2F0aW9uL3Byb2dyZXNzOyB3ZSBvbmx5IGNhbGwgaXQgb25jZSBoZXJlXHJcbiAgICAgICAgc2V0U3RhdGUoeyBzdGF0dXM6ICduYXZpZ2F0aW5nJywgY3VycmVudFN0ZXBJbmRleDogMCwgc3RlcHM6IHBsYW4uc3RlcHMgfSlcclxuICAgICAgICBhd2FpdCBwbGF5U3RlcChwbGFuLnN0ZXBzWzBdKVxyXG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogZT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicgfSkpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIGJhc2VDb25maWcsIHBsYXlTdGVwLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBwYXVzZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnBhdXNlKClcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoc3ludGggJiYgc3ludGguc3BlYWtpbmcgJiYgIXN5bnRoLnBhdXNlZCkgc3ludGgucGF1c2UoKVxyXG4gICAgfSBjYXRjaCB7fVxyXG4gICAgLy8gUGF1c2UgZmFsbGJhY2sgdGltZXIgcHJvZ3Jlc3MgaWYgcnVubmluZ1xyXG4gICAgaWYgKCF0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ID09IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChwcm9ncmVzc1RpbWVyLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShwcm9ncmVzc1RpbWVyLmN1cnJlbnQpXHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGF1c2VkJyB9KSlcclxuICB9LCBbYXVkaW9dKVxyXG5cclxuICBjb25zdCBza2lwVG8gPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChpbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGNvbnN0IHN0ZXBzID0gc3RhdGUuc3RlcHNcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzdGVwcy5sZW5ndGgpIHJldHVyblxyXG4gICAgICAvLyBTdG9wIGF1ZGlvIGFuZCBzcGVlY2ggYW5kIHJlc2V0IHByb2dyZXNzIGJlZm9yZSBzd2l0Y2hpbmdcclxuICAgICAgYXVkaW8uc3RvcCgpXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgY3VycmVudFN0ZXBJbmRleDogaW5kZXggfSkpXHJcbiAgICAgIGF3YWl0IHBsYXlTdGVwKHN0ZXBzW2luZGV4XSlcclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIHBsYXlTdGVwLCBzdGF0ZS5zdGVwcywgc3RvcFByb2dyZXNzXVxyXG4gIClcclxuXHJcbiAgY29uc3QgcmVzdW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgYXVkaW8ucmVzdW1lKClcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN5bnRoID0gd2luZG93LnNwZWVjaFN5bnRoZXNpc1xyXG4gICAgICBpZiAoc3ludGggJiYgc3ludGgucGF1c2VkKSBzeW50aC5yZXN1bWUoKVxyXG4gICAgfSBjYXRjaCB7fVxyXG4gICAgLy8gUmVzdW1lIGZhbGxiYWNrIHRpbWVyIHByb2dyZXNzIGlmIGJvdW5kYXJ5IG5vdCBhdmFpbGFibGVcclxuICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgaWYgKHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NQYXVzZUFjY3VtLmN1cnJlbnQgKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnRcclxuICAgICAgICBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFwcm9ncmVzc1RpbWVyLmN1cnJlbnQgJiYgcHJvZ3Jlc3MgPCAxKSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2tQcm9ncmVzcylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSWYgYSBwb3N0LXNsaWRlIHByb21wdCB3YXMgc2hvd24sIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHN0ZXBcclxuICAgIGlmIChuZXh0QWZ0ZXJQcm9tcHRSZWYuY3VycmVudCAmJiBwZW5kaW5nTmV4dEluZGV4UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xyXG4gICAgICBjb25zdCBpZHggPSBwZW5kaW5nTmV4dEluZGV4UmVmLmN1cnJlbnRcclxuICAgICAgbmV4dEFmdGVyUHJvbXB0UmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICBwZW5kaW5nTmV4dEluZGV4UmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIC8vIFN3aXRjaCB0byBuZXh0IHN0ZXBcclxuICAgICAgc2tpcFRvKGlkeClcclxuICAgICAgcmV0dXJuXHJcbiAgICB9XHJcbiAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGxheWluZycgfSkpXHJcbiAgfSwgW2F1ZGlvLCBwcm9ncmVzcywgdGlja1Byb2dyZXNzLCBza2lwVG9dKVxyXG5cclxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgYXVkaW8uc3RvcCgpXHJcbiAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgc2V0U3RhdGUoeyBzdGF0dXM6ICdzdG9wcGVkJywgY3VycmVudFN0ZXBJbmRleDogLTEsIHN0ZXBzOiBbXSB9KVxyXG4gIH0sIFthdWRpbywgc3RvcFByb2dyZXNzXSlcclxuXHJcbiAgLy8gUHVibGljIHVzZXItaW5pdGlhdGVkIGp1bXA6IHByZXZlbnQgYXV0by1hZHZhbmNlIGZyb20gY2hhaW5pbmcgb3ZlciB0aGUgdXNlcuKAmXMgc2VsZWN0aW9uXHJcbiAgY29uc3QganVtcFRvID0gdXNlQ2FsbGJhY2soYXN5bmMgKGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgIHVzZXJTa2lwUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICBhd2FpdCBza2lwVG8oaW5kZXgpXHJcbiAgfSwgW3NraXBUb10pXHJcblxyXG4gIC8vIEF1dG8tYWR2YW5jZSB3aGVuIHByb2dyZXNzIGNvbXBsZXRlcyBBTkQgVFRTIChpZiBhbnkpIGhhcyBlbmRlZC5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gQ2hlY2tpbmcgY29uZGl0aW9uczonLCB7XHJcbiAgICAgIHN0YXR1czogc3RhdGUuc3RhdHVzLFxyXG4gICAgICBwcm9ncmVzcyxcclxuICAgICAgdHRzQWN0aXZlLFxyXG4gICAgICB1c2VyU2tpcDogdXNlclNraXBSZWYuY3VycmVudCxcclxuICAgICAgaXNBZHZhbmNpbmc6IGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQsXHJcbiAgICB9KVxyXG4gICAgaWYgKHN0YXRlLnN0YXR1cyAhPT0gJ3BsYXlpbmcnIHx8IHByb2dyZXNzIDwgMSB8fCB0dHNBY3RpdmUpIHJldHVyblxyXG4gICAgLy8gSWYgdXNlciBqdXN0IGp1bXBlZCwgZG8gbm90IGF1dG8tYWR2YW5jZSBmcm9tIHRoZSBvbGQgc3RlcCBjb21wbGV0aW9uXHJcbiAgICBpZiAodXNlclNraXBSZWYuY3VycmVudCkgcmV0dXJuXHJcbiAgICBpZiAoaXNBZHZhbmNpbmdSZWYuY3VycmVudCkgcmV0dXJuXHJcbiAgICBpc0FkdmFuY2luZ1JlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gVFJJR0dFUklORyAtIFByb2dyZXNzIGNvbXBsZXRlIGFuZCBUVFMgZW5kZWQnKVxyXG4gICAgOyhhc3luYyAoKSA9PiB7XHJcbiAgICAgIC8vIEFmdGVyIGVhY2ggc2xpZGUgbmFycmF0aW9uIGZpbmlzaGVzLCBwYXVzZSBhbmQgcHJvbXB0IHRoZSB1c2VyXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0b0FkdmFuY2VdIFBhdXNpbmcgYWdlbnQuLi4nKVxyXG4gICAgICB0cnkgeyBwYXVzZSgpIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcignW0F1dG9BZHZhbmNlXSBQYXVzZSBlcnJvcjonLCBlKSB9XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0b0FkdmFuY2VdIENhbGxpbmcgcG9zdFNsaWRlUHJvbXB0UmVmLmN1cnJlbnQ/LihcIkRvIHlvdSB1bmRlcnN0YW5kP1wiKScpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQXV0b0FkdmFuY2VdIHBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50IGV4aXN0czonLCAhIXBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50KVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50Py4oJ0RvIHlvdSB1bmRlcnN0YW5kPycpXHJcbiAgICAgIH0gY2F0Y2ggKGUpIHsgY29uc29sZS5lcnJvcignW0F1dG9BZHZhbmNlXSBQcm9tcHQgY2FsbGJhY2sgZXJyb3I6JywgZSkgfVxyXG4gICAgICBjb25zdCBuZXh0ID0gc3RhdGUuY3VycmVudFN0ZXBJbmRleCArIDFcclxuICAgICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gTmV4dCBpbmRleDonLCBuZXh0LCAnVG90YWwgc3RlcHM6Jywgc3RhdGUuc3RlcHMubGVuZ3RoKVxyXG4gICAgICBpZiAobmV4dCA8IHN0YXRlLnN0ZXBzLmxlbmd0aCkge1xyXG4gICAgICAgIG5leHRBZnRlclByb21wdFJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIHBlbmRpbmdOZXh0SW5kZXhSZWYuY3VycmVudCA9IG5leHRcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBFbmQgb2YgcGxhbjogYmVoYXZlIGxpa2UgU3RvcCBmb3IgYSBmcmVzaC1yZWFkeSBzdGF0ZVxyXG4gICAgICAgIHN0b3AoKVxyXG4gICAgICB9XHJcbiAgICB9KSgpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICBpc0FkdmFuY2luZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgIH0pXHJcbiAgfSwgW3Byb2dyZXNzLCB0dHNBY3RpdmUsIHN0YXRlLnN0YXR1cywgc3RhdGUuY3VycmVudFN0ZXBJbmRleCwgc3RhdGUuc3RlcHMubGVuZ3RoLCBwYXVzZSwgc3RvcF0pXHJcblxyXG4gIC8vIEhvb2sgdXAgZXh0ZXJuYWwgcHJvbXB0IGhhbmRsZXIgZnJvbSBvcHRzXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIHBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50ID0gb3B0cz8ub25Qcm9tcHQgPz8gbnVsbFxyXG4gICAgcmV0dXJuICgpID0+IHsgcG9zdFNsaWRlUHJvbXB0UmVmLmN1cnJlbnQgPSBudWxsIH1cclxuICB9LCBbb3B0cz8ub25Qcm9tcHRdKVxyXG5cclxuICBjb25zdCBjdXJyZW50U3RlcCA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgaWYgKHN0YXRlLmN1cnJlbnRTdGVwSW5kZXggPCAwKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICByZXR1cm4gc3RhdGUuc3RlcHNbc3RhdGUuY3VycmVudFN0ZXBJbmRleF1cclxuICB9LCBbc3RhdGUuY3VycmVudFN0ZXBJbmRleCwgc3RhdGUuc3RlcHNdKVxyXG5cclxuICBjb25zdCByZXF1ZXN0UHJvbXB0ID0gKG1lc3NhZ2U/OiBzdHJpbmcpID0+IHtcclxuICAgIHBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50Py4obWVzc2FnZSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7IHN0YXRlLCBjdXJyZW50U3RlcCwgc3RhcnQsIHBhdXNlLCByZXN1bWUsIHN0b3AsIHNraXBUbywganVtcFRvLCBwcm9ncmVzcywgcmVxdWVzdFByb21wdCB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiZmV0Y2hBZ2VudFBsYW4iLCJ1c2VBdWRpb0NvbnRyb2xsZXIiLCJ1c2VBZ2VudENvbnRyb2xsZXIiLCJwZGZSZWYiLCJiYXNlQ29uZmlnIiwib3B0cyIsInN0YXRlIiwic2V0U3RhdGUiLCJzdGF0dXMiLCJjdXJyZW50U3RlcEluZGV4Iiwic3RlcHMiLCJhdWRpbyIsInByb2dyZXNzIiwic2V0UHJvZ3Jlc3MiLCJwcm9ncmVzc1RpbWVyIiwicHJvZ3Jlc3NTdGFydCIsInByb2dyZXNzRHVyYXRpb24iLCJwcm9ncmVzc1BhdXNlZEF0IiwicHJvZ3Jlc3NQYXVzZUFjY3VtIiwicGVuZGluZ05hdiIsInR0c0FjdGl2ZSIsInNldFR0c0FjdGl2ZSIsInR0c0FjdGl2ZVJlZiIsImlzQWR2YW5jaW5nUmVmIiwidHRzVGV4dExlblJlZiIsInR0c0JvdW5kYXJ5U2VlblJlZiIsInR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZiIsInR0c1N0YXJ0UmVmIiwiZXN0aW1hdGVkVG90YWxNc1JlZiIsImNoYXJSYXRlUmVmIiwidHRzVGV4dFJlZiIsInR0c1dvcmRTdGFydHNSZWYiLCJ0dHNUb3RhbFdvcmRzUmVmIiwidXNlclNraXBSZWYiLCJwb3N0U2xpZGVQcm9tcHRSZWYiLCJuZXh0QWZ0ZXJQcm9tcHRSZWYiLCJwZW5kaW5nTmV4dEluZGV4UmVmIiwibmF2aWdhdGVUbyIsInBhZ2UiLCJnbyIsIm5hdmlnYXRlIiwiYXBpIiwiY3VycmVudCIsImdvVG9QYWdlIiwiUHJvbWlzZSIsInIiLCJzZXRUaW1lb3V0IiwicCIsImZpbmFsbHkiLCJzdG9wUHJvZ3Jlc3MiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsInRpY2tQcm9ncmVzcyIsIm5vdyIsInBlcmZvcm1hbmNlIiwicGF1c2VkIiwicGF1c2VBZGoiLCJlbGFwc2VkIiwicGN0IiwiTWF0aCIsIm1pbiIsIm1heCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInN0YXJ0UHJvZ3Jlc3MiLCJkdXJhdGlvbk1zIiwiY2FuY2VsU3BlZWNoIiwic3BlYWtUZXh0IiwidGV4dCIsImZhbGxiYWNrTXMiLCJ3aW5kb3ciLCJjbGVhclRpbWVvdXQiLCJsZW5ndGgiLCJyZWdleCIsIm0iLCJleGVjIiwiaW5kZXgiLCJwdXNoIiwic3ludGgiLCJzcGVlY2hTeW50aGVzaXMiLCJzcGVha2luZyIsImNhbmNlbCIsInV0dGVyIiwiU3BlZWNoU3ludGhlc2lzVXR0ZXJhbmNlIiwicmF0ZSIsIm9uc3RhcnQiLCJvbmJvdW5kYXJ5IiwiZXYiLCJpZHgiLCJjaGFySW5kZXgiLCJzdGFydHMiLCJ0b3RhbFdvcmRzIiwibG93IiwiaGlnaCIsIm1pZCIsInNwb2tlbldvcmRzIiwicGN0V29yZHMiLCJvbmVuZCIsInNwZWFrIiwicGxheVN0ZXAiLCJzdGVwIiwicyIsInR0c1RleHQiLCJ0cmFuc2NyaXB0Iiwic3BlYWtNcyIsInBsYXkiLCJhdWRpb1VybCIsImNhdGNoIiwic3RhcnQiLCJjZmciLCJzdG9wIiwiZXJyb3IiLCJ1bmRlZmluZWQiLCJwbGFuIiwiRXJyb3IiLCJlIiwibWVzc2FnZSIsInBhdXNlIiwic2tpcFRvIiwicmVzdW1lIiwianVtcFRvIiwiY29uc29sZSIsImxvZyIsInVzZXJTa2lwIiwiaXNBZHZhbmNpbmciLCJuZXh0Iiwib25Qcm9tcHQiLCJjdXJyZW50U3RlcCIsInJlcXVlc3RQcm9tcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/useAgentController.ts\n"));

/***/ })

});