"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/useAgentController.ts":
/*!*********************************************!*\
  !*** ./src/lib/agent/useAgentController.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgentController: function() { return /* binding */ useAgentController; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mockApi */ \"(app-pages-browser)/./src/lib/agent/mockApi.ts\");\n/* harmony import */ var _lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/audio/useAudioController */ \"(app-pages-browser)/./src/lib/audio/useAudioController.ts\");\n/* __next_internal_client_entry_do_not_use__ useAgentController auto */ \n\n\nfunction useAgentController(pdfRef, baseConfig, opts) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        status: \"idle\",\n        currentStepIndex: -1,\n        steps: []\n    });\n    const audio = (0,_lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__.useAudioController)();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const progressTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pendingNav = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [ttsActive, setTtsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ttsActiveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isAdvancingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsTextLenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsBoundarySeenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsBoundaryFallbackTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ttsStartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const estimatedTotalMsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const charRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsTextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const ttsWordStartsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const ttsTotalWordsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const navigateTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (page)=>{\n        const go = async ()=>{\n            if (opts === null || opts === void 0 ? void 0 : opts.navigate) {\n                opts.navigate(page);\n            } else {\n                const api = pdfRef.current;\n                api === null || api === void 0 ? void 0 : api.goToPage(page);\n            }\n            await new Promise((r)=>setTimeout(r, 150));\n        };\n        const p = go().finally(()=>{\n            if (pendingNav.current === p) pendingNav.current = null;\n        });\n        pendingNav.current = p;\n        await p;\n    }, [\n        opts,\n        pdfRef\n    ]);\n    const stopProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressTimer.current) {\n            cancelAnimationFrame(progressTimer.current);\n            progressTimer.current = null;\n        }\n    }, []);\n    const startProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((durationMs)=>{\n        stopProgress();\n        setProgress(0);\n        progressDuration.current = Math.max(1000, durationMs);\n        progressStart.current = performance.now();\n        const tick = ()=>{\n            const elapsed = performance.now() - progressStart.current;\n            // Timer-based fallback when no boundaries; if boundaries show up, we stop this timer elsewhere\n            let pct = Math.min(1, elapsed / progressDuration.current);\n            // Avoid reaching 100% while TTS is still speaking to prevent early advance\n            if (ttsActiveRef.current && pct >= 1) {\n                pct = 0.98;\n            }\n            setProgress(pct);\n            if (pct < 1 || ttsActiveRef.current) {\n                progressTimer.current = requestAnimationFrame(tick);\n            } else {\n                progressTimer.current = null;\n            }\n        };\n        progressTimer.current = requestAnimationFrame(tick);\n    }, [\n        stopProgress\n    ]);\n    const cancelSpeech = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const speakText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text, fallbackMs)=>{\n        // Clear any prior boundary fallback timer\n        if (ttsBoundaryFallbackTimerRef.current) {\n            window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n            ttsBoundaryFallbackTimerRef.current = null;\n        }\n        ttsBoundarySeenRef.current = false;\n        var _text_length;\n        ttsTextLenRef.current = (_text_length = text === null || text === void 0 ? void 0 : text.length) !== null && _text_length !== void 0 ? _text_length : 0;\n        ttsTextRef.current = text || \"\";\n        // Precompute word starts for boundary-to-word mapping\n        ttsWordStartsRef.current = [];\n        ttsTotalWordsRef.current = 0;\n        if (text) {\n            const regex = /\\b\\w[\\w'\\-]*\\b/g;\n            let m;\n            while((m = regex.exec(text)) !== null){\n                if (typeof m.index === \"number\") {\n                    ttsWordStartsRef.current.push(m.index);\n                }\n            }\n            ttsTotalWordsRef.current = ttsWordStartsRef.current.length;\n        }\n        if (!text) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n        try {\n            const synth = window.speechSynthesis;\n            if (!synth) return ()=>{};\n            if (synth.speaking) synth.cancel();\n            const utter = new SpeechSynthesisUtterance(text);\n            // Keep a consistent rate for predictability\n            utter.rate = 1;\n            utter.onstart = ()=>{\n                setTtsActive(true);\n                ttsActiveRef.current = true;\n                ttsStartRef.current = performance.now();\n                charRateRef.current = 0;\n                estimatedTotalMsRef.current = fallbackMs || 5000;\n                // Always run a tick; if boundaries show up, it will adapt to time-based estimation\n                startProgress(estimatedTotalMsRef.current);\n            };\n            // Use boundary events to reflect real-time progress\n            utter.onboundary = (ev)=>{\n                ttsBoundarySeenRef.current = true;\n                // Stop timer fallback; boundary will drive progress\n                stopProgress();\n                const idx = typeof (ev === null || ev === void 0 ? void 0 : ev.charIndex) === \"number\" ? ev.charIndex : 0;\n                const starts = ttsWordStartsRef.current;\n                const totalWords = Math.max(1, ttsTotalWordsRef.current);\n                // Count words whose start index is <= current char index\n                let low = 0, high = starts.length;\n                while(low < high){\n                    const mid = low + high >> 1;\n                    if (starts[mid] <= idx) low = mid + 1;\n                    else high = mid;\n                }\n                const spokenWords = Math.min(low, totalWords);\n                let pctWords = spokenWords / totalWords;\n                if (ttsActiveRef.current && pctWords >= 1) pctWords = 0.98;\n                setProgress(pctWords);\n            };\n            utter.onend = ()=>{\n                setTtsActive(false);\n                ttsActiveRef.current = false;\n                // Complete progress and stop timer; auto-advance effect will pick this up\n                stopProgress();\n                setProgress(1);\n            };\n            synth.speak(utter);\n            // If boundary events arenâ€™t supported, start a fallback progress timer after a short delay\n            if (fallbackMs && fallbackMs > 0) {\n                ttsBoundaryFallbackTimerRef.current = window.setTimeout(()=>{\n                    if (!ttsBoundarySeenRef.current) {\n                        startProgress(fallbackMs);\n                    }\n                }, 700);\n            }\n            const cancel = ()=>{\n                try {\n                    synth.cancel();\n                } finally{\n                    setTtsActive(false);\n                    ttsActiveRef.current = false;\n                    if (ttsBoundaryFallbackTimerRef.current) {\n                        window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n                        ttsBoundaryFallbackTimerRef.current = null;\n                    }\n                }\n            };\n            return cancel;\n        } catch (e) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n    }, [\n        startProgress,\n        stopProgress\n    ]);\n    const playStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (step)=>{\n        var // Prefer TTS-driven progress via boundaries; fallback to a timer if boundaries arenâ€™t supported\n        _cancelSpeech_current;\n        // Ensure fresh progress/tts state for this step to avoid auto-advance races\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        setState((s)=>({\n                ...s,\n                status: \"navigating\"\n            }));\n        await navigateTo(step.page);\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        var _step_speakMs;\n        cancelSpeech.current = speakText(step.ttsText || step.transcript, (_step_speakMs = step.speakMs) !== null && _step_speakMs !== void 0 ? _step_speakMs : 5000);\n        // Optionally try audio as a subtle background beep if available\n        // but we no longer rely on audio end to advance\n        audio.play(step.audioUrl).catch(()=>{});\n    }, [\n        audio,\n        navigateTo,\n        speakText,\n        stopProgress\n    ]);\n    const start = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cfg)=>{\n        var _cancelSpeech_current;\n        // Clean up any prior run to ensure fresh state\n        try {\n            audio.stop();\n        } catch (e) {}\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        isAdvancingRef.current = false;\n        pendingNav.current = null;\n        setState((s)=>({\n                ...s,\n                status: \"fetching\",\n                error: undefined\n            }));\n        try {\n            const plan = await (0,_mockApi__WEBPACK_IMPORTED_MODULE_1__.fetchAgentPlan)({\n                ...baseConfig,\n                ...cfg\n            });\n            if (!plan.steps.length) throw new Error(\"No steps returned\");\n            // Initialize and let playStep handle navigation/progress; we only call it once here\n            setState({\n                status: \"navigating\",\n                currentStepIndex: 0,\n                steps: plan.steps\n            });\n            await playStep(plan.steps[0]);\n        } catch (e) {\n            setState((s)=>({\n                    ...s,\n                    status: \"error\",\n                    error: (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\"\n                }));\n        }\n    }, [\n        audio,\n        baseConfig,\n        playStep,\n        stopProgress\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.pause();\n        setState((s)=>({\n                ...s,\n                status: \"paused\"\n            }));\n    }, [\n        audio\n    ]);\n    const resume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.resume();\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n    }, [\n        audio\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cancelSpeech_current;\n        audio.stop();\n        stopProgress();\n        setProgress(0);\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        setState({\n            status: \"stopped\",\n            currentStepIndex: -1,\n            steps: []\n        });\n    }, [\n        audio,\n        stopProgress\n    ]);\n    const skipTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        var _cancelSpeech_current;\n        const steps = state.steps;\n        if (index < 0 || index >= steps.length) return;\n        // Stop audio and speech and reset progress before switching\n        audio.stop();\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setState((s)=>({\n                ...s,\n                currentStepIndex: index\n            }));\n        await playStep(steps[index]);\n    }, [\n        audio,\n        playStep,\n        state.steps,\n        stopProgress\n    ]);\n    // Auto-advance when progress completes AND TTS (if any) has ended.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (state.status !== \"playing\" || progress < 1 || ttsActive) return;\n        if (isAdvancingRef.current) return;\n        isAdvancingRef.current = true;\n        (async ()=>{\n            const next = state.currentStepIndex + 1;\n            if (next < state.steps.length) {\n                await skipTo(next);\n            } else {\n                // End of plan: behave like Stop for a fresh-ready state\n                stop();\n            }\n        })().finally(()=>{\n            isAdvancingRef.current = false;\n        });\n    }, [\n        progress,\n        ttsActive,\n        state.status,\n        state.currentStepIndex,\n        state.steps.length,\n        skipTo,\n        stop\n    ]);\n    const currentStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (state.currentStepIndex < 0) return undefined;\n        return state.steps[state.currentStepIndex];\n    }, [\n        state.currentStepIndex,\n        state.steps\n    ]);\n    return {\n        state,\n        currentStep,\n        start,\n        pause,\n        resume,\n        stop,\n        skipTo,\n        progress\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dFQUV5RTtBQUUvQjtBQUV5QjtBQWM1RCxTQUFTTyxtQkFDZEMsTUFBdUMsRUFDdkNDLFVBQThCLEVBQzlCQyxJQUE0QztJQUU1QyxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR1IsK0NBQVFBLENBQXVCO1FBQ3ZEUyxRQUFRO1FBQ1JDLGtCQUFrQixDQUFDO1FBQ25CQyxPQUFPLEVBQUU7SUFDWDtJQUNBLE1BQU1DLFFBQVFWLGlGQUFrQkE7SUFDaEMsTUFBTSxDQUFDVyxVQUFVQyxZQUFZLEdBQUdkLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU1lLGdCQUFnQmhCLDZDQUFNQSxDQUFnQjtJQUM1QyxNQUFNaUIsZ0JBQWdCakIsNkNBQU1BLENBQVM7SUFDckMsTUFBTWtCLG1CQUFtQmxCLDZDQUFNQSxDQUFTO0lBQ3hDLE1BQU1tQixhQUFhbkIsNkNBQU1BLENBQXVCO0lBQ2hELE1BQU0sQ0FBQ29CLFdBQVdDLGFBQWEsR0FBR3BCLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU1xQixlQUFldEIsNkNBQU1BLENBQUM7SUFDNUIsTUFBTXVCLGlCQUFpQnZCLDZDQUFNQSxDQUFDO0lBQzlCLE1BQU13QixnQkFBZ0J4Qiw2Q0FBTUEsQ0FBQztJQUM3QixNQUFNeUIscUJBQXFCekIsNkNBQU1BLENBQUM7SUFDbEMsTUFBTTBCLDhCQUE4QjFCLDZDQUFNQSxDQUFnQjtJQUMxRCxNQUFNMkIsY0FBYzNCLDZDQUFNQSxDQUFnQjtJQUMxQyxNQUFNNEIsc0JBQXNCNUIsNkNBQU1BLENBQVM7SUFDM0MsTUFBTTZCLGNBQWM3Qiw2Q0FBTUEsQ0FBUztJQUNuQyxNQUFNOEIsYUFBYTlCLDZDQUFNQSxDQUFTO0lBQ2xDLE1BQU0rQixtQkFBbUIvQiw2Q0FBTUEsQ0FBVyxFQUFFO0lBQzVDLE1BQU1nQyxtQkFBbUJoQyw2Q0FBTUEsQ0FBUztJQUV4QyxNQUFNaUMsYUFBYXBDLGtEQUFXQSxDQUFDLE9BQU9xQztRQUNwQyxNQUFNQyxLQUFLO1lBQ1QsSUFBSTVCLGlCQUFBQSwyQkFBQUEsS0FBTTZCLFFBQVEsRUFBRTtnQkFDbEI3QixLQUFLNkIsUUFBUSxDQUFDRjtZQUNoQixPQUFPO2dCQUNMLE1BQU1HLE1BQU1oQyxPQUFPaUMsT0FBTztnQkFDMUJELGdCQUFBQSwwQkFBQUEsSUFBS0UsUUFBUSxDQUFDTDtZQUNoQjtZQUNBLE1BQU0sSUFBSU0sUUFBUSxDQUFDQyxJQUFNQyxXQUFXRCxHQUFHO1FBQ3pDO1FBQ0EsTUFBTUUsSUFBSVIsS0FBS1MsT0FBTyxDQUFDO1lBQ3JCLElBQUl6QixXQUFXbUIsT0FBTyxLQUFLSyxHQUFHeEIsV0FBV21CLE9BQU8sR0FBRztRQUNyRDtRQUNBbkIsV0FBV21CLE9BQU8sR0FBR0s7UUFDckIsTUFBTUE7SUFDUixHQUFHO1FBQUNwQztRQUFNRjtLQUFPO0lBRWpCLE1BQU13QyxlQUFlaEQsa0RBQVdBLENBQUM7UUFDL0IsSUFBSW1CLGNBQWNzQixPQUFPLEVBQUU7WUFDekJRLHFCQUFxQjlCLGNBQWNzQixPQUFPO1lBQzFDdEIsY0FBY3NCLE9BQU8sR0FBRztRQUMxQjtJQUNGLEdBQUcsRUFBRTtJQUVMLE1BQU1TLGdCQUFnQmxELGtEQUFXQSxDQUFDLENBQUNtRDtRQUNqQ0g7UUFDQTlCLFlBQVk7UUFDWkcsaUJBQWlCb0IsT0FBTyxHQUFHVyxLQUFLQyxHQUFHLENBQUMsTUFBTUY7UUFDMUMvQixjQUFjcUIsT0FBTyxHQUFHYSxZQUFZQyxHQUFHO1FBQ3ZDLE1BQU1DLE9BQU87WUFDWCxNQUFNQyxVQUFVSCxZQUFZQyxHQUFHLEtBQUtuQyxjQUFjcUIsT0FBTztZQUN6RCwrRkFBK0Y7WUFDL0YsSUFBSWlCLE1BQU1OLEtBQUtPLEdBQUcsQ0FBQyxHQUFHRixVQUFVcEMsaUJBQWlCb0IsT0FBTztZQUN4RCwyRUFBMkU7WUFDM0UsSUFBSWhCLGFBQWFnQixPQUFPLElBQUlpQixPQUFPLEdBQUc7Z0JBQ3BDQSxNQUFNO1lBQ1I7WUFDQXhDLFlBQVl3QztZQUNaLElBQUlBLE1BQU0sS0FBS2pDLGFBQWFnQixPQUFPLEVBQUU7Z0JBQ25DdEIsY0FBY3NCLE9BQU8sR0FBR21CLHNCQUFzQko7WUFDaEQsT0FBTztnQkFDTHJDLGNBQWNzQixPQUFPLEdBQUc7WUFDMUI7UUFDRjtRQUNBdEIsY0FBY3NCLE9BQU8sR0FBR21CLHNCQUFzQko7SUFDaEQsR0FBRztRQUFDUjtLQUFhO0lBRWpCLE1BQU1hLGVBQWUxRCw2Q0FBTUEsQ0FBc0I7SUFFakQsTUFBTTJELFlBQVk5RCxrREFBV0EsQ0FBQyxDQUFDK0QsTUFBMEJDO1FBQ3ZELDBDQUEwQztRQUMxQyxJQUFJbkMsNEJBQTRCWSxPQUFPLEVBQUU7WUFDdkN3QixPQUFPQyxZQUFZLENBQUNyQyw0QkFBNEJZLE9BQU87WUFDdkRaLDRCQUE0QlksT0FBTyxHQUFHO1FBQ3hDO1FBQ0FiLG1CQUFtQmEsT0FBTyxHQUFHO1lBQ0xzQjtRQUF4QnBDLGNBQWNjLE9BQU8sR0FBR3NCLENBQUFBLGVBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTUksTUFBTSxjQUFaSiwwQkFBQUEsZUFBZ0I7UUFDeEM5QixXQUFXUSxPQUFPLEdBQUdzQixRQUFRO1FBQzdCLHNEQUFzRDtRQUN0RDdCLGlCQUFpQk8sT0FBTyxHQUFHLEVBQUU7UUFDN0JOLGlCQUFpQk0sT0FBTyxHQUFHO1FBQzNCLElBQUlzQixNQUFNO1lBQ1IsTUFBTUssUUFBUTtZQUNkLElBQUlDO1lBQ0osTUFBTyxDQUFDQSxJQUFJRCxNQUFNRSxJQUFJLENBQUNQLEtBQUksTUFBTyxLQUFNO2dCQUN0QyxJQUFJLE9BQU9NLEVBQUVFLEtBQUssS0FBSyxVQUFVO29CQUMvQnJDLGlCQUFpQk8sT0FBTyxDQUFDK0IsSUFBSSxDQUFDSCxFQUFFRSxLQUFLO2dCQUN2QztZQUNGO1lBQ0FwQyxpQkFBaUJNLE9BQU8sR0FBR1AsaUJBQWlCTyxPQUFPLENBQUMwQixNQUFNO1FBQzVEO1FBRUEsSUFBSSxDQUFDSixNQUFNO1lBQ1R2QyxhQUFhO1lBQ2JDLGFBQWFnQixPQUFPLEdBQUc7WUFDdkIsT0FBTyxLQUFPO1FBQ2hCO1FBQ0EsSUFBSTtZQUNGLE1BQU1nQyxRQUFRUixPQUFPUyxlQUFlO1lBQ3BDLElBQUksQ0FBQ0QsT0FBTyxPQUFPLEtBQU87WUFDMUIsSUFBSUEsTUFBTUUsUUFBUSxFQUFFRixNQUFNRyxNQUFNO1lBQ2hDLE1BQU1DLFFBQVEsSUFBSUMseUJBQXlCZjtZQUMzQyw0Q0FBNEM7WUFDNUNjLE1BQU1FLElBQUksR0FBRztZQUNiRixNQUFNRyxPQUFPLEdBQUc7Z0JBQ2R4RCxhQUFhO2dCQUNiQyxhQUFhZ0IsT0FBTyxHQUFHO2dCQUN2QlgsWUFBWVcsT0FBTyxHQUFHYSxZQUFZQyxHQUFHO2dCQUNyQ3ZCLFlBQVlTLE9BQU8sR0FBRztnQkFDdEJWLG9CQUFvQlUsT0FBTyxHQUFHdUIsY0FBYztnQkFDNUMsbUZBQW1GO2dCQUNuRmQsY0FBY25CLG9CQUFvQlUsT0FBTztZQUMzQztZQUNBLG9EQUFvRDtZQUNwRG9DLE1BQU1JLFVBQVUsR0FBRyxDQUFDQztnQkFDbEJ0RCxtQkFBbUJhLE9BQU8sR0FBRztnQkFDN0Isb0RBQW9EO2dCQUNwRE87Z0JBQ0EsTUFBTW1DLE1BQWMsUUFBT0QsZUFBQUEseUJBQUFBLEdBQUlFLFNBQVMsTUFBSyxXQUFXRixHQUFHRSxTQUFTLEdBQUc7Z0JBQ3ZFLE1BQU1DLFNBQVNuRCxpQkFBaUJPLE9BQU87Z0JBQ3ZDLE1BQU02QyxhQUFhbEMsS0FBS0MsR0FBRyxDQUFDLEdBQUdsQixpQkFBaUJNLE9BQU87Z0JBQ3ZELHlEQUF5RDtnQkFDekQsSUFBSThDLE1BQU0sR0FBR0MsT0FBT0gsT0FBT2xCLE1BQU07Z0JBQ2pDLE1BQU9vQixNQUFNQyxLQUFNO29CQUNqQixNQUFNQyxNQUFNLE1BQU9ELFFBQVM7b0JBQzVCLElBQUlILE1BQU0sQ0FBQ0ksSUFBSSxJQUFJTixLQUFLSSxNQUFNRSxNQUFNO3lCQUMvQkQsT0FBT0M7Z0JBQ2Q7Z0JBQ0EsTUFBTUMsY0FBY3RDLEtBQUtPLEdBQUcsQ0FBQzRCLEtBQUtEO2dCQUNsQyxJQUFJSyxXQUFXRCxjQUFjSjtnQkFDN0IsSUFBSTdELGFBQWFnQixPQUFPLElBQUlrRCxZQUFZLEdBQUdBLFdBQVc7Z0JBQ3REekUsWUFBWXlFO1lBQ2Q7WUFDQWQsTUFBTWUsS0FBSyxHQUFHO2dCQUNacEUsYUFBYTtnQkFDYkMsYUFBYWdCLE9BQU8sR0FBRztnQkFDdkIsMEVBQTBFO2dCQUMxRU87Z0JBQ0E5QixZQUFZO1lBQ2Q7WUFDQXVELE1BQU1vQixLQUFLLENBQUNoQjtZQUVaLDJGQUEyRjtZQUMzRixJQUFJYixjQUFjQSxhQUFhLEdBQUc7Z0JBQ2hDbkMsNEJBQTRCWSxPQUFPLEdBQUd3QixPQUFPcEIsVUFBVSxDQUFDO29CQUN0RCxJQUFJLENBQUNqQixtQkFBbUJhLE9BQU8sRUFBRTt3QkFDL0JTLGNBQWNjO29CQUNoQjtnQkFDRixHQUFHO1lBQ0w7WUFFQSxNQUFNWSxTQUFTO2dCQUNiLElBQUk7b0JBQ0ZILE1BQU1HLE1BQU07Z0JBQ2QsU0FBVTtvQkFDUnBELGFBQWE7b0JBQ2JDLGFBQWFnQixPQUFPLEdBQUc7b0JBQ3ZCLElBQUlaLDRCQUE0QlksT0FBTyxFQUFFO3dCQUN2Q3dCLE9BQU9DLFlBQVksQ0FBQ3JDLDRCQUE0QlksT0FBTzt3QkFDdkRaLDRCQUE0QlksT0FBTyxHQUFHO29CQUN4QztnQkFDRjtZQUNGO1lBQ0EsT0FBT21DO1FBQ1QsRUFBRSxVQUFNO1lBQ05wRCxhQUFhO1lBQ2JDLGFBQWFnQixPQUFPLEdBQUc7WUFDdkIsT0FBTyxLQUFPO1FBQ2hCO0lBQ0YsR0FBRztRQUFDUztRQUFlRjtLQUFhO0lBRWhDLE1BQU04QyxXQUFXOUYsa0RBQVdBLENBQzFCLE9BQU8rRjtZQVNMLGdHQUFnRztRQUNoR2xDO1FBVEEsNEVBQTRFO1FBQzVFYjtRQUNBOUIsWUFBWTtRQUNaTSxhQUFhO1FBQ2JDLGFBQWFnQixPQUFPLEdBQUc7UUFDdkI3QixTQUFTLENBQUNvRixJQUFPO2dCQUFFLEdBQUdBLENBQUM7Z0JBQUVuRixRQUFRO1lBQWE7UUFDOUMsTUFBTXVCLFdBQVcyRCxLQUFLMUQsSUFBSTtRQUMxQnpCLFNBQVMsQ0FBQ29GLElBQU87Z0JBQUUsR0FBR0EsQ0FBQztnQkFBRW5GLFFBQVE7WUFBVTtTQUUzQ2dELHdCQUFBQSxhQUFhcEIsT0FBTyxjQUFwQm9CLDRDQUFBQSwyQkFBQUE7WUFDa0VrQztRQUFsRWxDLGFBQWFwQixPQUFPLEdBQUdxQixVQUFVaUMsS0FBS0UsT0FBTyxJQUFJRixLQUFLRyxVQUFVLEVBQUVILENBQUFBLGdCQUFBQSxLQUFLSSxPQUFPLGNBQVpKLDJCQUFBQSxnQkFBZ0I7UUFDbEYsZ0VBQWdFO1FBQ2hFLGdEQUFnRDtRQUNoRC9FLE1BQU1vRixJQUFJLENBQUNMLEtBQUtNLFFBQVEsRUFBRUMsS0FBSyxDQUFDLEtBQU87SUFDekMsR0FDQTtRQUFDdEY7UUFBT29CO1FBQVkwQjtRQUFXZDtLQUFhO0lBRzlDLE1BQU11RCxRQUFRdkcsa0RBQVdBLENBQ3ZCLE9BQU93RztZQUtMM0M7UUFKQSwrQ0FBK0M7UUFDL0MsSUFBSTtZQUNGN0MsTUFBTXlGLElBQUk7UUFDWixFQUFFLFVBQU0sQ0FBQztTQUNUNUMsd0JBQUFBLGFBQWFwQixPQUFPLGNBQXBCb0IsNENBQUFBLDJCQUFBQTtRQUNBYjtRQUNBOUIsWUFBWTtRQUNaTSxhQUFhO1FBQ2JDLGFBQWFnQixPQUFPLEdBQUc7UUFDdkJmLGVBQWVlLE9BQU8sR0FBRztRQUN6Qm5CLFdBQVdtQixPQUFPLEdBQUc7UUFFckI3QixTQUFTLENBQUNvRixJQUFPO2dCQUFFLEdBQUdBLENBQUM7Z0JBQUVuRixRQUFRO2dCQUFZNkYsT0FBT0M7WUFBVTtRQUM5RCxJQUFJO1lBQ0YsTUFBTUMsT0FBTyxNQUFNdkcsd0RBQWNBLENBQUM7Z0JBQUUsR0FBR0ksVUFBVTtnQkFBRSxHQUFHK0YsR0FBRztZQUFDO1lBQzFELElBQUksQ0FBQ0ksS0FBSzdGLEtBQUssQ0FBQ29ELE1BQU0sRUFBRSxNQUFNLElBQUkwQyxNQUFNO1lBQ3hDLG9GQUFvRjtZQUNwRmpHLFNBQVM7Z0JBQUVDLFFBQVE7Z0JBQWNDLGtCQUFrQjtnQkFBR0MsT0FBTzZGLEtBQUs3RixLQUFLO1lBQUM7WUFDeEUsTUFBTStFLFNBQVNjLEtBQUs3RixLQUFLLENBQUMsRUFBRTtRQUM5QixFQUFFLE9BQU8rRixHQUFRO1lBQ2ZsRyxTQUFTLENBQUNvRixJQUFPO29CQUFFLEdBQUdBLENBQUM7b0JBQUVuRixRQUFRO29CQUFTNkYsT0FBT0ksQ0FBQUEsY0FBQUEsd0JBQUFBLEVBQUdDLE9BQU8sS0FBSTtnQkFBZ0I7UUFDakY7SUFDRixHQUNBO1FBQUMvRjtRQUFPUDtRQUFZcUY7UUFBVTlDO0tBQWE7SUFHN0MsTUFBTWdFLFFBQVFoSCxrREFBV0EsQ0FBQztRQUN4QmdCLE1BQU1nRyxLQUFLO1FBQ1hwRyxTQUFTLENBQUNvRixJQUFPO2dCQUFFLEdBQUdBLENBQUM7Z0JBQUVuRixRQUFRO1lBQVM7SUFDNUMsR0FBRztRQUFDRztLQUFNO0lBRVYsTUFBTWlHLFNBQVNqSCxrREFBV0EsQ0FBQztRQUN6QmdCLE1BQU1pRyxNQUFNO1FBQ1pyRyxTQUFTLENBQUNvRixJQUFPO2dCQUFFLEdBQUdBLENBQUM7Z0JBQUVuRixRQUFRO1lBQVU7SUFDN0MsR0FBRztRQUFDRztLQUFNO0lBRVYsTUFBTXlGLE9BQU96RyxrREFBV0EsQ0FBQztZQUl2QjZEO1FBSEE3QyxNQUFNeUYsSUFBSTtRQUNWekQ7UUFDQTlCLFlBQVk7U0FDWjJDLHdCQUFBQSxhQUFhcEIsT0FBTyxjQUFwQm9CLDRDQUFBQSwyQkFBQUE7UUFDQWpELFNBQVM7WUFBRUMsUUFBUTtZQUFXQyxrQkFBa0IsQ0FBQztZQUFHQyxPQUFPLEVBQUU7UUFBQztJQUNoRSxHQUFHO1FBQUNDO1FBQU9nQztLQUFhO0lBRXhCLE1BQU1rRSxTQUFTbEgsa0RBQVdBLENBQ3hCLE9BQU91RTtZQUtMVjtRQUpBLE1BQU05QyxRQUFRSixNQUFNSSxLQUFLO1FBQ3pCLElBQUl3RCxRQUFRLEtBQUtBLFNBQVN4RCxNQUFNb0QsTUFBTSxFQUFFO1FBQ3hDLDREQUE0RDtRQUM1RG5ELE1BQU15RixJQUFJO1NBQ1Y1Qyx3QkFBQUEsYUFBYXBCLE9BQU8sY0FBcEJvQiw0Q0FBQUEsMkJBQUFBO1FBQ0FiO1FBQ0E5QixZQUFZO1FBQ1pOLFNBQVMsQ0FBQ29GLElBQU87Z0JBQUUsR0FBR0EsQ0FBQztnQkFBRWxGLGtCQUFrQnlEO1lBQU07UUFDakQsTUFBTXVCLFNBQVMvRSxLQUFLLENBQUN3RCxNQUFNO0lBQzdCLEdBQ0E7UUFBQ3ZEO1FBQU84RTtRQUFVbkYsTUFBTUksS0FBSztRQUFFaUM7S0FBYTtJQUc5QyxtRUFBbUU7SUFDbkUvQyxnREFBU0EsQ0FBQztRQUNSLElBQUlVLE1BQU1FLE1BQU0sS0FBSyxhQUFhSSxXQUFXLEtBQUtNLFdBQVc7UUFDN0QsSUFBSUcsZUFBZWUsT0FBTyxFQUFFO1FBQzVCZixlQUFlZSxPQUFPLEdBQUc7UUFDdkI7WUFDQSxNQUFNMEUsT0FBT3hHLE1BQU1HLGdCQUFnQixHQUFHO1lBQ3RDLElBQUlxRyxPQUFPeEcsTUFBTUksS0FBSyxDQUFDb0QsTUFBTSxFQUFFO2dCQUM3QixNQUFNK0MsT0FBT0M7WUFDZixPQUFPO2dCQUNMLHdEQUF3RDtnQkFDeERWO1lBQ0Y7UUFDRixLQUFLMUQsT0FBTyxDQUFDO1lBQ1hyQixlQUFlZSxPQUFPLEdBQUc7UUFDM0I7SUFDRixHQUFHO1FBQUN4QjtRQUFVTTtRQUFXWixNQUFNRSxNQUFNO1FBQUVGLE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLLENBQUNvRCxNQUFNO1FBQUUrQztRQUFRVDtLQUFLO0lBRWhHLE1BQU1XLGNBQWNsSCw4Q0FBT0EsQ0FBQztRQUMxQixJQUFJUyxNQUFNRyxnQkFBZ0IsR0FBRyxHQUFHLE9BQU82RjtRQUN2QyxPQUFPaEcsTUFBTUksS0FBSyxDQUFDSixNQUFNRyxnQkFBZ0IsQ0FBQztJQUM1QyxHQUFHO1FBQUNILE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLO0tBQUM7SUFFeEMsT0FBTztRQUFFSjtRQUFPeUc7UUFBYWI7UUFBT1M7UUFBT0M7UUFBUVI7UUFBTVM7UUFBUWpHO0lBQVM7QUFDNUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hZ2VudC91c2VBZ2VudENvbnRyb2xsZXIudHM/NGUyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHR5cGUgeyBQZGZDYXJvdXNlbFJlZiB9IGZyb20gJ0AvY29tcG9uZW50cy9QZGZDYXJvdXNlbCdcclxuaW1wb3J0IHsgZmV0Y2hBZ2VudFBsYW4gfSBmcm9tICcuL21vY2tBcGknXHJcbmltcG9ydCB0eXBlIHsgQWdlbnRDb250cm9sbGVyU3RhdGUsIEFnZW50U2Vzc2lvbkNvbmZpZywgQWdlbnRTdGVwIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgdXNlQXVkaW9Db250cm9sbGVyIH0gZnJvbSAnQC9saWIvYXVkaW8vdXNlQXVkaW9Db250cm9sbGVyJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIHN0YXRlOiBBZ2VudENvbnRyb2xsZXJTdGF0ZVxyXG4gIGN1cnJlbnRTdGVwPzogQWdlbnRTdGVwXHJcbiAgc3RhcnQ6IChjZmc/OiBQYXJ0aWFsPEFnZW50U2Vzc2lvbkNvbmZpZz4pID0+IFByb21pc2U8dm9pZD5cclxuICBwYXVzZTogKCkgPT4gdm9pZFxyXG4gIHJlc3VtZTogKCkgPT4gdm9pZFxyXG4gIHN0b3A6ICgpID0+IHZvaWRcclxuICBza2lwVG86IChpbmRleDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgLy8gU2ltdWxhdGVkIHByb2dyZXNzIG9mIGN1cnJlbnQgc3RlcDogMC4uMVxyXG4gIHByb2dyZXNzOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFnZW50Q29udHJvbGxlcihcclxuICBwZGZSZWY6IFJlYWN0LlJlZk9iamVjdDxQZGZDYXJvdXNlbFJlZj4sXHJcbiAgYmFzZUNvbmZpZzogQWdlbnRTZXNzaW9uQ29uZmlnLFxyXG4gIG9wdHM/OiB7IG5hdmlnYXRlPzogKHBhZ2U6IG51bWJlcikgPT4gdm9pZCB9XHJcbik6IEFnZW50Q29udHJvbGxlckFwaSB7XHJcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZTxBZ2VudENvbnRyb2xsZXJTdGF0ZT4oe1xyXG4gICAgc3RhdHVzOiAnaWRsZScsXHJcbiAgICBjdXJyZW50U3RlcEluZGV4OiAtMSxcclxuICAgIHN0ZXBzOiBbXSxcclxuICB9KVxyXG4gIGNvbnN0IGF1ZGlvID0gdXNlQXVkaW9Db250cm9sbGVyKClcclxuICBjb25zdCBbcHJvZ3Jlc3MsIHNldFByb2dyZXNzXSA9IHVzZVN0YXRlKDApXHJcbiAgY29uc3QgcHJvZ3Jlc3NUaW1lciA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHByb2dyZXNzU3RhcnQgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IHByb2dyZXNzRHVyYXRpb24gPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IHBlbmRpbmdOYXYgPSB1c2VSZWY8UHJvbWlzZTx2b2lkPiB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgW3R0c0FjdGl2ZSwgc2V0VHRzQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gIGNvbnN0IHR0c0FjdGl2ZVJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCBpc0FkdmFuY2luZ1JlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCB0dHNUZXh0TGVuUmVmID0gdXNlUmVmKDApXHJcbiAgY29uc3QgdHRzQm91bmRhcnlTZWVuUmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IHR0c1N0YXJ0UmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgZXN0aW1hdGVkVG90YWxNc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgY2hhclJhdGVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IHR0c1RleHRSZWYgPSB1c2VSZWY8c3RyaW5nPignJylcclxuICBjb25zdCB0dHNXb3JkU3RhcnRzUmVmID0gdXNlUmVmPG51bWJlcltdPihbXSlcclxuICBjb25zdCB0dHNUb3RhbFdvcmRzUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuXHJcbiAgY29uc3QgbmF2aWdhdGVUbyA9IHVzZUNhbGxiYWNrKGFzeW5jIChwYWdlOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IGdvID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAob3B0cz8ubmF2aWdhdGUpIHtcclxuICAgICAgICBvcHRzLm5hdmlnYXRlKHBhZ2UpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYXBpID0gcGRmUmVmLmN1cnJlbnRcclxuICAgICAgICBhcGk/LmdvVG9QYWdlKHBhZ2UpXHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMTUwKSlcclxuICAgIH1cclxuICAgIGNvbnN0IHAgPSBnbygpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICBpZiAocGVuZGluZ05hdi5jdXJyZW50ID09PSBwKSBwZW5kaW5nTmF2LmN1cnJlbnQgPSBudWxsXHJcbiAgICB9KVxyXG4gICAgcGVuZGluZ05hdi5jdXJyZW50ID0gcFxyXG4gICAgYXdhaXQgcFxyXG4gIH0sIFtvcHRzLCBwZGZSZWZdKVxyXG5cclxuICBjb25zdCBzdG9wUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAocHJvZ3Jlc3NUaW1lci5jdXJyZW50KSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXIuY3VycmVudClcclxuICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICBjb25zdCBzdGFydFByb2dyZXNzID0gdXNlQ2FsbGJhY2soKGR1cmF0aW9uTXM6IG51bWJlcikgPT4ge1xyXG4gICAgc3RvcFByb2dyZXNzKClcclxuICAgIHNldFByb2dyZXNzKDApXHJcbiAgICBwcm9ncmVzc0R1cmF0aW9uLmN1cnJlbnQgPSBNYXRoLm1heCgxMDAwLCBkdXJhdGlvbk1zKVxyXG4gICAgcHJvZ3Jlc3NTdGFydC5jdXJyZW50ID0gcGVyZm9ybWFuY2Uubm93KClcclxuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XHJcbiAgICAgIGNvbnN0IGVsYXBzZWQgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2dyZXNzU3RhcnQuY3VycmVudFxyXG4gICAgICAvLyBUaW1lci1iYXNlZCBmYWxsYmFjayB3aGVuIG5vIGJvdW5kYXJpZXM7IGlmIGJvdW5kYXJpZXMgc2hvdyB1cCwgd2Ugc3RvcCB0aGlzIHRpbWVyIGVsc2V3aGVyZVxyXG4gICAgICBsZXQgcGN0ID0gTWF0aC5taW4oMSwgZWxhcHNlZCAvIHByb2dyZXNzRHVyYXRpb24uY3VycmVudClcclxuICAgICAgLy8gQXZvaWQgcmVhY2hpbmcgMTAwJSB3aGlsZSBUVFMgaXMgc3RpbGwgc3BlYWtpbmcgdG8gcHJldmVudCBlYXJseSBhZHZhbmNlXHJcbiAgICAgIGlmICh0dHNBY3RpdmVSZWYuY3VycmVudCAmJiBwY3QgPj0gMSkge1xyXG4gICAgICAgIHBjdCA9IDAuOThcclxuICAgICAgfVxyXG4gICAgICBzZXRQcm9ncmVzcyhwY3QpXHJcbiAgICAgIGlmIChwY3QgPCAxIHx8IHR0c0FjdGl2ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gbnVsbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljaylcclxuICB9LCBbc3RvcFByb2dyZXNzXSlcclxuXHJcbiAgY29uc3QgY2FuY2VsU3BlZWNoID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXHJcblxyXG4gIGNvbnN0IHNwZWFrVGV4dCA9IHVzZUNhbGxiYWNrKCh0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsIGZhbGxiYWNrTXM/OiBudW1iZXIpID0+IHtcclxuICAgIC8vIENsZWFyIGFueSBwcmlvciBib3VuZGFyeSBmYWxsYmFjayB0aW1lclxyXG4gICAgaWYgKHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpXHJcbiAgICAgIHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gICAgdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgdHRzVGV4dExlblJlZi5jdXJyZW50ID0gdGV4dD8ubGVuZ3RoID8/IDBcclxuICAgIHR0c1RleHRSZWYuY3VycmVudCA9IHRleHQgfHwgJydcclxuICAgIC8vIFByZWNvbXB1dGUgd29yZCBzdGFydHMgZm9yIGJvdW5kYXJ5LXRvLXdvcmQgbWFwcGluZ1xyXG4gICAgdHRzV29yZFN0YXJ0c1JlZi5jdXJyZW50ID0gW11cclxuICAgIHR0c1RvdGFsV29yZHNSZWYuY3VycmVudCA9IDBcclxuICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL1xcYlxcd1tcXHcnXFwtXSpcXGIvZ1xyXG4gICAgICBsZXQgbTogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxyXG4gICAgICB3aGlsZSAoKG0gPSByZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbS5pbmRleCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHR0c1dvcmRTdGFydHNSZWYuY3VycmVudC5wdXNoKG0uaW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHR0c1RvdGFsV29yZHNSZWYuY3VycmVudCA9IHR0c1dvcmRTdGFydHNSZWYuY3VycmVudC5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRleHQpIHtcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHJldHVybiAoKSA9PiB7fVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3ludGggPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzXHJcbiAgICAgIGlmICghc3ludGgpIHJldHVybiAoKSA9PiB7fVxyXG4gICAgICBpZiAoc3ludGguc3BlYWtpbmcpIHN5bnRoLmNhbmNlbCgpXHJcbiAgICAgIGNvbnN0IHV0dGVyID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSh0ZXh0KVxyXG4gICAgICAvLyBLZWVwIGEgY29uc2lzdGVudCByYXRlIGZvciBwcmVkaWN0YWJpbGl0eVxyXG4gICAgICB1dHRlci5yYXRlID0gMVxyXG4gICAgICB1dHRlci5vbnN0YXJ0ID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFR0c0FjdGl2ZSh0cnVlKVxyXG4gICAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIHR0c1N0YXJ0UmVmLmN1cnJlbnQgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgICAgIGNoYXJSYXRlUmVmLmN1cnJlbnQgPSAwXHJcbiAgICAgICAgZXN0aW1hdGVkVG90YWxNc1JlZi5jdXJyZW50ID0gZmFsbGJhY2tNcyB8fCA1MDAwXHJcbiAgICAgICAgLy8gQWx3YXlzIHJ1biBhIHRpY2s7IGlmIGJvdW5kYXJpZXMgc2hvdyB1cCwgaXQgd2lsbCBhZGFwdCB0byB0aW1lLWJhc2VkIGVzdGltYXRpb25cclxuICAgICAgICBzdGFydFByb2dyZXNzKGVzdGltYXRlZFRvdGFsTXNSZWYuY3VycmVudClcclxuICAgICAgfVxyXG4gICAgICAvLyBVc2UgYm91bmRhcnkgZXZlbnRzIHRvIHJlZmxlY3QgcmVhbC10aW1lIHByb2dyZXNzXHJcbiAgICAgIHV0dGVyLm9uYm91bmRhcnkgPSAoZXY6IGFueSkgPT4ge1xyXG4gICAgICAgIHR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIC8vIFN0b3AgdGltZXIgZmFsbGJhY2s7IGJvdW5kYXJ5IHdpbGwgZHJpdmUgcHJvZ3Jlc3NcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIGNvbnN0IGlkeDogbnVtYmVyID0gdHlwZW9mIGV2Py5jaGFySW5kZXggPT09ICdudW1iZXInID8gZXYuY2hhckluZGV4IDogMFxyXG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IHR0c1dvcmRTdGFydHNSZWYuY3VycmVudFxyXG4gICAgICAgIGNvbnN0IHRvdGFsV29yZHMgPSBNYXRoLm1heCgxLCB0dHNUb3RhbFdvcmRzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgLy8gQ291bnQgd29yZHMgd2hvc2Ugc3RhcnQgaW5kZXggaXMgPD0gY3VycmVudCBjaGFyIGluZGV4XHJcbiAgICAgICAgbGV0IGxvdyA9IDAsIGhpZ2ggPSBzdGFydHMubGVuZ3RoXHJcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxXHJcbiAgICAgICAgICBpZiAoc3RhcnRzW21pZF0gPD0gaWR4KSBsb3cgPSBtaWQgKyAxXHJcbiAgICAgICAgICBlbHNlIGhpZ2ggPSBtaWRcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3Bva2VuV29yZHMgPSBNYXRoLm1pbihsb3csIHRvdGFsV29yZHMpXHJcbiAgICAgICAgbGV0IHBjdFdvcmRzID0gc3Bva2VuV29yZHMgLyB0b3RhbFdvcmRzXHJcbiAgICAgICAgaWYgKHR0c0FjdGl2ZVJlZi5jdXJyZW50ICYmIHBjdFdvcmRzID49IDEpIHBjdFdvcmRzID0gMC45OFxyXG4gICAgICAgIHNldFByb2dyZXNzKHBjdFdvcmRzKVxyXG4gICAgICB9XHJcbiAgICAgIHV0dGVyLm9uZW5kID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgLy8gQ29tcGxldGUgcHJvZ3Jlc3MgYW5kIHN0b3AgdGltZXI7IGF1dG8tYWR2YW5jZSBlZmZlY3Qgd2lsbCBwaWNrIHRoaXMgdXBcclxuICAgICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICAgIHNldFByb2dyZXNzKDEpXHJcbiAgICAgIH1cclxuICAgICAgc3ludGguc3BlYWsodXR0ZXIpXHJcblxyXG4gICAgICAvLyBJZiBib3VuZGFyeSBldmVudHMgYXJlbuKAmXQgc3VwcG9ydGVkLCBzdGFydCBhIGZhbGxiYWNrIHByb2dyZXNzIHRpbWVyIGFmdGVyIGEgc2hvcnQgZGVsYXlcclxuICAgICAgaWYgKGZhbGxiYWNrTXMgJiYgZmFsbGJhY2tNcyA+IDApIHtcclxuICAgICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIGlmICghdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgc3RhcnRQcm9ncmVzcyhmYWxsYmFja01zKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIDcwMClcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2FuY2VsID0gKCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBzeW50aC5jYW5jZWwoKVxyXG4gICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgICBpZiAodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudClcclxuICAgICAgICAgICAgdHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBjYW5jZWxcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgcmV0dXJuICgpID0+IHt9XHJcbiAgICB9XHJcbiAgfSwgW3N0YXJ0UHJvZ3Jlc3MsIHN0b3BQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHBsYXlTdGVwID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAoc3RlcDogQWdlbnRTdGVwKSA9PiB7XHJcbiAgICAgIC8vIEVuc3VyZSBmcmVzaCBwcm9ncmVzcy90dHMgc3RhdGUgZm9yIHRoaXMgc3RlcCB0byBhdm9pZCBhdXRvLWFkdmFuY2UgcmFjZXNcclxuICAgICAgc3RvcFByb2dyZXNzKClcclxuICAgICAgc2V0UHJvZ3Jlc3MoMClcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICduYXZpZ2F0aW5nJyB9KSlcclxuICAgICAgYXdhaXQgbmF2aWdhdGVUbyhzdGVwLnBhZ2UpXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwbGF5aW5nJyB9KSlcclxuICAgICAgLy8gUHJlZmVyIFRUUy1kcml2ZW4gcHJvZ3Jlc3MgdmlhIGJvdW5kYXJpZXM7IGZhbGxiYWNrIHRvIGEgdGltZXIgaWYgYm91bmRhcmllcyBhcmVu4oCZdCBzdXBwb3J0ZWRcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50ID0gc3BlYWtUZXh0KHN0ZXAudHRzVGV4dCB8fCBzdGVwLnRyYW5zY3JpcHQsIHN0ZXAuc3BlYWtNcyA/PyA1MDAwKVxyXG4gICAgICAvLyBPcHRpb25hbGx5IHRyeSBhdWRpbyBhcyBhIHN1YnRsZSBiYWNrZ3JvdW5kIGJlZXAgaWYgYXZhaWxhYmxlXHJcbiAgICAgIC8vIGJ1dCB3ZSBubyBsb25nZXIgcmVseSBvbiBhdWRpbyBlbmQgdG8gYWR2YW5jZVxyXG4gICAgICBhdWRpby5wbGF5KHN0ZXAuYXVkaW9VcmwpLmNhdGNoKCgpID0+IHt9KVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgbmF2aWdhdGVUbywgc3BlYWtUZXh0LCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBzdGFydCA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGNmZz86IFBhcnRpYWw8QWdlbnRTZXNzaW9uQ29uZmlnPikgPT4ge1xyXG4gICAgICAvLyBDbGVhbiB1cCBhbnkgcHJpb3IgcnVuIHRvIGVuc3VyZSBmcmVzaCBzdGF0ZVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGF1ZGlvLnN0b3AoKVxyXG4gICAgICB9IGNhdGNoIHt9XHJcbiAgICAgIGNhbmNlbFNwZWVjaC5jdXJyZW50Py4oKVxyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgaXNBZHZhbmNpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHBlbmRpbmdOYXYuY3VycmVudCA9IG51bGxcclxuXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdmZXRjaGluZycsIGVycm9yOiB1bmRlZmluZWQgfSkpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGxhbiA9IGF3YWl0IGZldGNoQWdlbnRQbGFuKHsgLi4uYmFzZUNvbmZpZywgLi4uY2ZnIH0pXHJcbiAgICAgICAgaWYgKCFwbGFuLnN0ZXBzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdObyBzdGVwcyByZXR1cm5lZCcpXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbmQgbGV0IHBsYXlTdGVwIGhhbmRsZSBuYXZpZ2F0aW9uL3Byb2dyZXNzOyB3ZSBvbmx5IGNhbGwgaXQgb25jZSBoZXJlXHJcbiAgICAgICAgc2V0U3RhdGUoeyBzdGF0dXM6ICduYXZpZ2F0aW5nJywgY3VycmVudFN0ZXBJbmRleDogMCwgc3RlcHM6IHBsYW4uc3RlcHMgfSlcclxuICAgICAgICBhd2FpdCBwbGF5U3RlcChwbGFuLnN0ZXBzWzBdKVxyXG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgICAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAnZXJyb3InLCBlcnJvcjogZT8ubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcicgfSkpXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBbYXVkaW8sIGJhc2VDb25maWcsIHBsYXlTdGVwLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCBwYXVzZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnBhdXNlKClcclxuICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwYXVzZWQnIH0pKVxyXG4gIH0sIFthdWRpb10pXHJcblxyXG4gIGNvbnN0IHJlc3VtZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnJlc3VtZSgpXHJcbiAgICBzZXRTdGF0ZSgocykgPT4gKHsgLi4ucywgc3RhdHVzOiAncGxheWluZycgfSkpXHJcbiAgfSwgW2F1ZGlvXSlcclxuXHJcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgIGF1ZGlvLnN0b3AoKVxyXG4gICAgc3RvcFByb2dyZXNzKClcclxuICAgIHNldFByb2dyZXNzKDApXHJcbiAgICBjYW5jZWxTcGVlY2guY3VycmVudD8uKClcclxuICAgIHNldFN0YXRlKHsgc3RhdHVzOiAnc3RvcHBlZCcsIGN1cnJlbnRTdGVwSW5kZXg6IC0xLCBzdGVwczogW10gfSlcclxuICB9LCBbYXVkaW8sIHN0b3BQcm9ncmVzc10pXHJcblxyXG4gIGNvbnN0IHNraXBUbyA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3Qgc3RlcHMgPSBzdGF0ZS5zdGVwc1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0ZXBzLmxlbmd0aCkgcmV0dXJuXHJcbiAgICAgIC8vIFN0b3AgYXVkaW8gYW5kIHNwZWVjaCBhbmQgcmVzZXQgcHJvZ3Jlc3MgYmVmb3JlIHN3aXRjaGluZ1xyXG4gICAgICBhdWRpby5zdG9wKClcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgIHNldFByb2dyZXNzKDApXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBjdXJyZW50U3RlcEluZGV4OiBpbmRleCB9KSlcclxuICAgICAgYXdhaXQgcGxheVN0ZXAoc3RlcHNbaW5kZXhdKVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgcGxheVN0ZXAsIHN0YXRlLnN0ZXBzLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICAvLyBBdXRvLWFkdmFuY2Ugd2hlbiBwcm9ncmVzcyBjb21wbGV0ZXMgQU5EIFRUUyAoaWYgYW55KSBoYXMgZW5kZWQuXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09ICdwbGF5aW5nJyB8fCBwcm9ncmVzcyA8IDEgfHwgdHRzQWN0aXZlKSByZXR1cm5cclxuICAgIGlmIChpc0FkdmFuY2luZ1JlZi5jdXJyZW50KSByZXR1cm5cclxuICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICA7KGFzeW5jICgpID0+IHtcclxuICAgICAgY29uc3QgbmV4dCA9IHN0YXRlLmN1cnJlbnRTdGVwSW5kZXggKyAxXHJcbiAgICAgIGlmIChuZXh0IDwgc3RhdGUuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgYXdhaXQgc2tpcFRvKG5leHQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRW5kIG9mIHBsYW46IGJlaGF2ZSBsaWtlIFN0b3AgZm9yIGEgZnJlc2gtcmVhZHkgc3RhdGVcclxuICAgICAgICBzdG9wKClcclxuICAgICAgfVxyXG4gICAgfSkoKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgaXNBZHZhbmNpbmdSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICB9KVxyXG4gIH0sIFtwcm9ncmVzcywgdHRzQWN0aXZlLCBzdGF0ZS5zdGF0dXMsIHN0YXRlLmN1cnJlbnRTdGVwSW5kZXgsIHN0YXRlLnN0ZXBzLmxlbmd0aCwgc2tpcFRvLCBzdG9wXSlcclxuXHJcbiAgY29uc3QgY3VycmVudFN0ZXAgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGlmIChzdGF0ZS5jdXJyZW50U3RlcEluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgcmV0dXJuIHN0YXRlLnN0ZXBzW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXhdXHJcbiAgfSwgW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXgsIHN0YXRlLnN0ZXBzXSlcclxuXHJcbiAgcmV0dXJuIHsgc3RhdGUsIGN1cnJlbnRTdGVwLCBzdGFydCwgcGF1c2UsIHJlc3VtZSwgc3RvcCwgc2tpcFRvLCBwcm9ncmVzcyB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwiZmV0Y2hBZ2VudFBsYW4iLCJ1c2VBdWRpb0NvbnRyb2xsZXIiLCJ1c2VBZ2VudENvbnRyb2xsZXIiLCJwZGZSZWYiLCJiYXNlQ29uZmlnIiwib3B0cyIsInN0YXRlIiwic2V0U3RhdGUiLCJzdGF0dXMiLCJjdXJyZW50U3RlcEluZGV4Iiwic3RlcHMiLCJhdWRpbyIsInByb2dyZXNzIiwic2V0UHJvZ3Jlc3MiLCJwcm9ncmVzc1RpbWVyIiwicHJvZ3Jlc3NTdGFydCIsInByb2dyZXNzRHVyYXRpb24iLCJwZW5kaW5nTmF2IiwidHRzQWN0aXZlIiwic2V0VHRzQWN0aXZlIiwidHRzQWN0aXZlUmVmIiwiaXNBZHZhbmNpbmdSZWYiLCJ0dHNUZXh0TGVuUmVmIiwidHRzQm91bmRhcnlTZWVuUmVmIiwidHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmIiwidHRzU3RhcnRSZWYiLCJlc3RpbWF0ZWRUb3RhbE1zUmVmIiwiY2hhclJhdGVSZWYiLCJ0dHNUZXh0UmVmIiwidHRzV29yZFN0YXJ0c1JlZiIsInR0c1RvdGFsV29yZHNSZWYiLCJuYXZpZ2F0ZVRvIiwicGFnZSIsImdvIiwibmF2aWdhdGUiLCJhcGkiLCJjdXJyZW50IiwiZ29Ub1BhZ2UiLCJQcm9taXNlIiwiciIsInNldFRpbWVvdXQiLCJwIiwiZmluYWxseSIsInN0b3BQcm9ncmVzcyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwic3RhcnRQcm9ncmVzcyIsImR1cmF0aW9uTXMiLCJNYXRoIiwibWF4IiwicGVyZm9ybWFuY2UiLCJub3ciLCJ0aWNrIiwiZWxhcHNlZCIsInBjdCIsIm1pbiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImNhbmNlbFNwZWVjaCIsInNwZWFrVGV4dCIsInRleHQiLCJmYWxsYmFja01zIiwid2luZG93IiwiY2xlYXJUaW1lb3V0IiwibGVuZ3RoIiwicmVnZXgiLCJtIiwiZXhlYyIsImluZGV4IiwicHVzaCIsInN5bnRoIiwic3BlZWNoU3ludGhlc2lzIiwic3BlYWtpbmciLCJjYW5jZWwiLCJ1dHRlciIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInJhdGUiLCJvbnN0YXJ0Iiwib25ib3VuZGFyeSIsImV2IiwiaWR4IiwiY2hhckluZGV4Iiwic3RhcnRzIiwidG90YWxXb3JkcyIsImxvdyIsImhpZ2giLCJtaWQiLCJzcG9rZW5Xb3JkcyIsInBjdFdvcmRzIiwib25lbmQiLCJzcGVhayIsInBsYXlTdGVwIiwic3RlcCIsInMiLCJ0dHNUZXh0IiwidHJhbnNjcmlwdCIsInNwZWFrTXMiLCJwbGF5IiwiYXVkaW9VcmwiLCJjYXRjaCIsInN0YXJ0IiwiY2ZnIiwic3RvcCIsImVycm9yIiwidW5kZWZpbmVkIiwicGxhbiIsIkVycm9yIiwiZSIsIm1lc3NhZ2UiLCJwYXVzZSIsInJlc3VtZSIsInNraXBUbyIsIm5leHQiLCJjdXJyZW50U3RlcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/useAgentController.ts\n"));

/***/ })

});