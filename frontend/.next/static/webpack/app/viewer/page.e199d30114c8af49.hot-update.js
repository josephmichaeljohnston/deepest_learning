"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/mockApi.ts":
/*!**********************************!*\
  !*** ./src/lib/agent/mockApi.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchAgentPlan: function() { return /* binding */ fetchAgentPlan; }\n/* harmony export */ });\n/* harmony import */ var _lib_pdf_extract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/pdf/extract */ \"(app-pages-browser)/./src/lib/pdf/extract.ts\");\n/* __next_internal_client_entry_do_not_use__ fetchAgentPlan auto */ \n// Simple helper to simulate network delay\nconst sleep = (ms)=>new Promise((res)=>setTimeout(res, ms));\n// A few royalty-free sample audio URLs (small, public). Fallback to a generated beep if blocked.\n// Note: In production, these would be signed URLs or served via your API.\nconst SAMPLE_AUDIO = [\n    // Public domain test tones; if blocked, the audio controller will fall back to a local beep.\n    \"https://actions.google.com/sounds/v1/alarms/beep_short.ogg\",\n    \"https://actions.google.com/sounds/v1/alarms/beep_short.ogg\",\n    \"https://actions.google.com/sounds/v1/alarms/beep_short.ogg\"\n];\nasync function fetchAgentPlan(config) {\n    // Simulate server thinking time\n    await sleep(600);\n    const { totalPages, strategy = \"scripted\", pdfUrl } = config;\n    // Helpers\n    const randInt = (min, max)=>Math.floor(Math.random() * (max - min + 1)) + min;\n    const uniqueSet = new Set();\n    // Phase A: randomized linear window\n    const maxLinear = Math.min(5, Math.max(1, totalPages));\n    const minLinear = Math.min(2, maxLinear);\n    const linearCount = totalPages >= 2 ? randInt(minLinear, maxLinear) : 1;\n    const maxStart = Math.max(1, totalPages - linearCount + 1);\n    const start = randInt(1, maxStart);\n    const linearPages = Array.from({\n        length: linearCount\n    }, (_, i)=>start + i);\n    linearPages.forEach((p)=>uniqueSet.add(p));\n    // Phase B: random unique pages not in linear window\n    const maxRandom = Math.min(5, totalPages);\n    const minRandom = Math.min(2, maxRandom) // allow 1 when totalPages=1\n    ;\n    const randomCount = maxRandom > 0 ? randInt(minRandom, maxRandom) : 0;\n    const randomPages = [];\n    while(randomPages.length < randomCount){\n        const n = randInt(1, totalPages);\n        if (!uniqueSet.has(n)) {\n            uniqueSet.add(n);\n            var _randomPages_;\n            // avoid repeating the last selected page between picks\n            const last = (_randomPages_ = randomPages[randomPages.length - 1]) !== null && _randomPages_ !== void 0 ? _randomPages_ : linearPages[linearPages.length - 1];\n            if (n !== last) randomPages.push(n);\n        }\n        // Break safety for tiny documents\n        if (uniqueSet.size >= totalPages) break;\n    }\n    const pages = strategy === \"linear\" ? linearPages : strategy === \"random\" ? randomPages : [\n        ...linearPages,\n        ...randomPages\n    ];\n    // Extract text (best-effort). Compute a speak time estimate based on word count (e.g., 150 wpm ~= 2.5 wps)\n    const steps = [];\n    for(let i = 0; i < pages.length; i++){\n        const page = pages[i];\n        let text = \"\";\n        if (pdfUrl) {\n            text = await (0,_lib_pdf_extract__WEBPACK_IMPORTED_MODULE_0__.extractPageText)(pdfUrl, page);\n        }\n        // Fallback transcript\n        const transcript = text || \"Narration for slide \".concat(page, \".\");\n        // Estimate: 2.5 words/second; min 4s, max 15s for demo\n        const words = transcript.split(/\\s+/).filter(Boolean).length;\n        const estimatedMs = Math.min(15000, Math.max(4000, Math.ceil(words / 2.5 * 1000)));\n        const inLinear = linearPages.includes(page);\n        steps.push({\n            page,\n            audioUrl: SAMPLE_AUDIO[i % SAMPLE_AUDIO.length],\n            transcript,\n            ttsText: transcript,\n            label: \"\".concat(inLinear ? \"Linear\" : \"Random\", \" â€¢ Slide \").concat(page),\n            speakMs: estimatedMs\n        });\n    }\n    return {\n        steps\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvbW9ja0FwaS50cyIsIm1hcHBpbmdzIjoiOzs7OztvRUFHbUQ7QUFFbkQsMENBQTBDO0FBQzFDLE1BQU1DLFFBQVEsQ0FBQ0MsS0FBZSxJQUFJQyxRQUFRLENBQUNDLE1BQVFDLFdBQVdELEtBQUtGO0FBRW5FLGlHQUFpRztBQUNqRywwRUFBMEU7QUFDMUUsTUFBTUksZUFBeUI7SUFDN0IsNkZBQTZGO0lBQzdGO0lBQ0E7SUFDQTtDQUNEO0FBRU0sZUFBZUMsZUFDcEJDLE1BQTBCO0lBRTFCLGdDQUFnQztJQUNoQyxNQUFNUCxNQUFNO0lBRVosTUFBTSxFQUFFUSxVQUFVLEVBQUVDLFdBQVcsVUFBVSxFQUFFQyxNQUFNLEVBQUUsR0FBR0g7SUFFdEQsVUFBVTtJQUNWLE1BQU1JLFVBQVUsQ0FBQ0MsS0FBYUMsTUFBZ0JDLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNSCxDQUFBQSxNQUFNRCxNQUFNLE1BQU1BO0lBQzVGLE1BQU1LLFlBQVksSUFBSUM7SUFFdEIsb0NBQW9DO0lBQ3BDLE1BQU1DLFlBQVlMLEtBQUtGLEdBQUcsQ0FBQyxHQUFHRSxLQUFLRCxHQUFHLENBQUMsR0FBR0w7SUFDMUMsTUFBTVksWUFBWU4sS0FBS0YsR0FBRyxDQUFDLEdBQUdPO0lBQzlCLE1BQU1FLGNBQWNiLGNBQWMsSUFBSUcsUUFBUVMsV0FBV0QsYUFBYTtJQUN0RSxNQUFNRyxXQUFXUixLQUFLRCxHQUFHLENBQUMsR0FBR0wsYUFBYWEsY0FBYztJQUN4RCxNQUFNRSxRQUFRWixRQUFRLEdBQUdXO0lBQ3pCLE1BQU1FLGNBQWNDLE1BQU1DLElBQUksQ0FBQztRQUFFQyxRQUFRTjtJQUFZLEdBQUcsQ0FBQ08sR0FBR0MsSUFBTU4sUUFBUU07SUFDMUVMLFlBQVlNLE9BQU8sQ0FBQ0MsQ0FBQUEsSUFBS2QsVUFBVWUsR0FBRyxDQUFDRDtJQUV2QyxvREFBb0Q7SUFDcEQsTUFBTUUsWUFBWW5CLEtBQUtGLEdBQUcsQ0FBQyxHQUFHSjtJQUM5QixNQUFNMEIsWUFBWXBCLEtBQUtGLEdBQUcsQ0FBQyxHQUFHcUIsV0FBVyw0QkFBNEI7O0lBQ3JFLE1BQU1FLGNBQWNGLFlBQVksSUFBSXRCLFFBQVF1QixXQUFXRCxhQUFhO0lBQ3BFLE1BQU1HLGNBQXdCLEVBQUU7SUFDaEMsTUFBT0EsWUFBWVQsTUFBTSxHQUFHUSxZQUFhO1FBQ3ZDLE1BQU1FLElBQUkxQixRQUFRLEdBQUdIO1FBQ3JCLElBQUksQ0FBQ1MsVUFBVXFCLEdBQUcsQ0FBQ0QsSUFBSTtZQUNyQnBCLFVBQVVlLEdBQUcsQ0FBQ0s7Z0JBRUREO1lBRGIsdURBQXVEO1lBQ3ZELE1BQU1HLE9BQU9ILENBQUFBLGdCQUFBQSxXQUFXLENBQUNBLFlBQVlULE1BQU0sR0FBRyxFQUFFLGNBQW5DUywyQkFBQUEsZ0JBQXVDWixXQUFXLENBQUNBLFlBQVlHLE1BQU0sR0FBRyxFQUFFO1lBQ3ZGLElBQUlVLE1BQU1FLE1BQU1ILFlBQVlJLElBQUksQ0FBQ0g7UUFDbkM7UUFDQSxrQ0FBa0M7UUFDbEMsSUFBSXBCLFVBQVV3QixJQUFJLElBQUlqQyxZQUFZO0lBQ3BDO0lBRUEsTUFBTWtDLFFBQVFqQyxhQUFhLFdBQVdlLGNBQWNmLGFBQWEsV0FBVzJCLGNBQWM7V0FBSVo7V0FBZ0JZO0tBQVk7SUFFMUgsMkdBQTJHO0lBQzNHLE1BQU1PLFFBQXFCLEVBQUU7SUFDN0IsSUFBSyxJQUFJZCxJQUFJLEdBQUdBLElBQUlhLE1BQU1mLE1BQU0sRUFBRUUsSUFBSztRQUNyQyxNQUFNZSxPQUFPRixLQUFLLENBQUNiLEVBQUU7UUFDckIsSUFBSWdCLE9BQU87UUFDWCxJQUFJbkMsUUFBUTtZQUNWbUMsT0FBTyxNQUFNOUMsaUVBQWVBLENBQUNXLFFBQVFrQztRQUN2QztRQUNBLHNCQUFzQjtRQUN0QixNQUFNRSxhQUFhRCxRQUFRLHVCQUE0QixPQUFMRCxNQUFLO1FBQ3ZELHVEQUF1RDtRQUN2RCxNQUFNRyxRQUFRRCxXQUFXRSxLQUFLLENBQUMsT0FBT0MsTUFBTSxDQUFDQyxTQUFTdkIsTUFBTTtRQUM1RCxNQUFNd0IsY0FBY3JDLEtBQUtGLEdBQUcsQ0FBQyxPQUFPRSxLQUFLRCxHQUFHLENBQUMsTUFBTUMsS0FBS3NDLElBQUksQ0FBQyxRQUFTLE1BQU87UUFDN0UsTUFBTUMsV0FBVzdCLFlBQVk4QixRQUFRLENBQUNWO1FBQ3RDRCxNQUFNSCxJQUFJLENBQUM7WUFDVEk7WUFDQVcsVUFBVWxELFlBQVksQ0FBQ3dCLElBQUl4QixhQUFhc0IsTUFBTSxDQUFDO1lBQy9DbUI7WUFDQVUsU0FBU1Y7WUFDVFcsT0FBTyxHQUE2Q2IsT0FBMUNTLFdBQVcsV0FBVyxVQUFTLGFBQWdCLE9BQUxUO1lBQ3BEYyxTQUFTUDtRQUNYO0lBQ0Y7SUFFQSxPQUFPO1FBQUVSO0lBQU07QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hZ2VudC9tb2NrQXBpLnRzPzZkMDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyBBZ2VudFNlc3Npb25Db25maWcsIEFnZW50U3RlcCB9IGZyb20gJy4vdHlwZXMnXHJcbmltcG9ydCB7IGV4dHJhY3RQYWdlVGV4dCB9IGZyb20gJ0AvbGliL3BkZi9leHRyYWN0J1xyXG5cclxuLy8gU2ltcGxlIGhlbHBlciB0byBzaW11bGF0ZSBuZXR3b3JrIGRlbGF5XHJcbmNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpXHJcblxyXG4vLyBBIGZldyByb3lhbHR5LWZyZWUgc2FtcGxlIGF1ZGlvIFVSTHMgKHNtYWxsLCBwdWJsaWMpLiBGYWxsYmFjayB0byBhIGdlbmVyYXRlZCBiZWVwIGlmIGJsb2NrZWQuXHJcbi8vIE5vdGU6IEluIHByb2R1Y3Rpb24sIHRoZXNlIHdvdWxkIGJlIHNpZ25lZCBVUkxzIG9yIHNlcnZlZCB2aWEgeW91ciBBUEkuXHJcbmNvbnN0IFNBTVBMRV9BVURJTzogc3RyaW5nW10gPSBbXHJcbiAgLy8gUHVibGljIGRvbWFpbiB0ZXN0IHRvbmVzOyBpZiBibG9ja2VkLCB0aGUgYXVkaW8gY29udHJvbGxlciB3aWxsIGZhbGwgYmFjayB0byBhIGxvY2FsIGJlZXAuXHJcbiAgJ2h0dHBzOi8vYWN0aW9ucy5nb29nbGUuY29tL3NvdW5kcy92MS9hbGFybXMvYmVlcF9zaG9ydC5vZ2cnLFxyXG4gICdodHRwczovL2FjdGlvbnMuZ29vZ2xlLmNvbS9zb3VuZHMvdjEvYWxhcm1zL2JlZXBfc2hvcnQub2dnJyxcclxuICAnaHR0cHM6Ly9hY3Rpb25zLmdvb2dsZS5jb20vc291bmRzL3YxL2FsYXJtcy9iZWVwX3Nob3J0Lm9nZycsXHJcbl1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaEFnZW50UGxhbihcclxuICBjb25maWc6IEFnZW50U2Vzc2lvbkNvbmZpZ1xyXG4pOiBQcm9taXNlPHsgc3RlcHM6IEFnZW50U3RlcFtdIH0+IHtcclxuICAvLyBTaW11bGF0ZSBzZXJ2ZXIgdGhpbmtpbmcgdGltZVxyXG4gIGF3YWl0IHNsZWVwKDYwMClcclxuXHJcbiAgY29uc3QgeyB0b3RhbFBhZ2VzLCBzdHJhdGVneSA9ICdzY3JpcHRlZCcsIHBkZlVybCB9ID0gY29uZmlnXHJcblxyXG4gIC8vIEhlbHBlcnNcclxuICBjb25zdCByYW5kSW50ID0gKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pblxyXG4gIGNvbnN0IHVuaXF1ZVNldCA9IG5ldyBTZXQ8bnVtYmVyPigpXHJcblxyXG4gIC8vIFBoYXNlIEE6IHJhbmRvbWl6ZWQgbGluZWFyIHdpbmRvd1xyXG4gIGNvbnN0IG1heExpbmVhciA9IE1hdGgubWluKDUsIE1hdGgubWF4KDEsIHRvdGFsUGFnZXMpKVxyXG4gIGNvbnN0IG1pbkxpbmVhciA9IE1hdGgubWluKDIsIG1heExpbmVhcilcclxuICBjb25zdCBsaW5lYXJDb3VudCA9IHRvdGFsUGFnZXMgPj0gMiA/IHJhbmRJbnQobWluTGluZWFyLCBtYXhMaW5lYXIpIDogMVxyXG4gIGNvbnN0IG1heFN0YXJ0ID0gTWF0aC5tYXgoMSwgdG90YWxQYWdlcyAtIGxpbmVhckNvdW50ICsgMSlcclxuICBjb25zdCBzdGFydCA9IHJhbmRJbnQoMSwgbWF4U3RhcnQpXHJcbiAgY29uc3QgbGluZWFyUGFnZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBsaW5lYXJDb3VudCB9LCAoXywgaSkgPT4gc3RhcnQgKyBpKVxyXG4gIGxpbmVhclBhZ2VzLmZvckVhY2gocCA9PiB1bmlxdWVTZXQuYWRkKHApKVxyXG5cclxuICAvLyBQaGFzZSBCOiByYW5kb20gdW5pcXVlIHBhZ2VzIG5vdCBpbiBsaW5lYXIgd2luZG93XHJcbiAgY29uc3QgbWF4UmFuZG9tID0gTWF0aC5taW4oNSwgdG90YWxQYWdlcylcclxuICBjb25zdCBtaW5SYW5kb20gPSBNYXRoLm1pbigyLCBtYXhSYW5kb20pIC8vIGFsbG93IDEgd2hlbiB0b3RhbFBhZ2VzPTFcclxuICBjb25zdCByYW5kb21Db3VudCA9IG1heFJhbmRvbSA+IDAgPyByYW5kSW50KG1pblJhbmRvbSwgbWF4UmFuZG9tKSA6IDBcclxuICBjb25zdCByYW5kb21QYWdlczogbnVtYmVyW10gPSBbXVxyXG4gIHdoaWxlIChyYW5kb21QYWdlcy5sZW5ndGggPCByYW5kb21Db3VudCkge1xyXG4gICAgY29uc3QgbiA9IHJhbmRJbnQoMSwgdG90YWxQYWdlcylcclxuICAgIGlmICghdW5pcXVlU2V0LmhhcyhuKSkge1xyXG4gICAgICB1bmlxdWVTZXQuYWRkKG4pXHJcbiAgICAgIC8vIGF2b2lkIHJlcGVhdGluZyB0aGUgbGFzdCBzZWxlY3RlZCBwYWdlIGJldHdlZW4gcGlja3NcclxuICAgICAgY29uc3QgbGFzdCA9IHJhbmRvbVBhZ2VzW3JhbmRvbVBhZ2VzLmxlbmd0aCAtIDFdID8/IGxpbmVhclBhZ2VzW2xpbmVhclBhZ2VzLmxlbmd0aCAtIDFdXHJcbiAgICAgIGlmIChuICE9PSBsYXN0KSByYW5kb21QYWdlcy5wdXNoKG4pXHJcbiAgICB9XHJcbiAgICAvLyBCcmVhayBzYWZldHkgZm9yIHRpbnkgZG9jdW1lbnRzXHJcbiAgICBpZiAodW5pcXVlU2V0LnNpemUgPj0gdG90YWxQYWdlcykgYnJlYWtcclxuICB9XHJcblxyXG4gIGNvbnN0IHBhZ2VzID0gc3RyYXRlZ3kgPT09ICdsaW5lYXInID8gbGluZWFyUGFnZXMgOiBzdHJhdGVneSA9PT0gJ3JhbmRvbScgPyByYW5kb21QYWdlcyA6IFsuLi5saW5lYXJQYWdlcywgLi4ucmFuZG9tUGFnZXNdXHJcblxyXG4gIC8vIEV4dHJhY3QgdGV4dCAoYmVzdC1lZmZvcnQpLiBDb21wdXRlIGEgc3BlYWsgdGltZSBlc3RpbWF0ZSBiYXNlZCBvbiB3b3JkIGNvdW50IChlLmcuLCAxNTAgd3BtIH49IDIuNSB3cHMpXHJcbiAgY29uc3Qgc3RlcHM6IEFnZW50U3RlcFtdID0gW11cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBwYWdlID0gcGFnZXNbaV1cclxuICAgIGxldCB0ZXh0ID0gJydcclxuICAgIGlmIChwZGZVcmwpIHtcclxuICAgICAgdGV4dCA9IGF3YWl0IGV4dHJhY3RQYWdlVGV4dChwZGZVcmwsIHBhZ2UpXHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjayB0cmFuc2NyaXB0XHJcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gdGV4dCB8fCBgTmFycmF0aW9uIGZvciBzbGlkZSAke3BhZ2V9LmBcclxuICAgIC8vIEVzdGltYXRlOiAyLjUgd29yZHMvc2Vjb25kOyBtaW4gNHMsIG1heCAxNXMgZm9yIGRlbW9cclxuICAgIGNvbnN0IHdvcmRzID0gdHJhbnNjcmlwdC5zcGxpdCgvXFxzKy8pLmZpbHRlcihCb29sZWFuKS5sZW5ndGhcclxuICAgIGNvbnN0IGVzdGltYXRlZE1zID0gTWF0aC5taW4oMTUwMDAsIE1hdGgubWF4KDQwMDAsIE1hdGguY2VpbCgod29yZHMgLyAyLjUpICogMTAwMCkpKVxyXG4gICAgY29uc3QgaW5MaW5lYXIgPSBsaW5lYXJQYWdlcy5pbmNsdWRlcyhwYWdlKVxyXG4gICAgc3RlcHMucHVzaCh7XHJcbiAgICAgIHBhZ2UsXHJcbiAgICAgIGF1ZGlvVXJsOiBTQU1QTEVfQVVESU9baSAlIFNBTVBMRV9BVURJTy5sZW5ndGhdLFxyXG4gICAgICB0cmFuc2NyaXB0LFxyXG4gICAgICB0dHNUZXh0OiB0cmFuc2NyaXB0LFxyXG4gICAgICBsYWJlbDogYCR7aW5MaW5lYXIgPyAnTGluZWFyJyA6ICdSYW5kb20nfSDigKIgU2xpZGUgJHtwYWdlfWAsXHJcbiAgICAgIHNwZWFrTXM6IGVzdGltYXRlZE1zLFxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7IHN0ZXBzIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZXh0cmFjdFBhZ2VUZXh0Iiwic2xlZXAiLCJtcyIsIlByb21pc2UiLCJyZXMiLCJzZXRUaW1lb3V0IiwiU0FNUExFX0FVRElPIiwiZmV0Y2hBZ2VudFBsYW4iLCJjb25maWciLCJ0b3RhbFBhZ2VzIiwic3RyYXRlZ3kiLCJwZGZVcmwiLCJyYW5kSW50IiwibWluIiwibWF4IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidW5pcXVlU2V0IiwiU2V0IiwibWF4TGluZWFyIiwibWluTGluZWFyIiwibGluZWFyQ291bnQiLCJtYXhTdGFydCIsInN0YXJ0IiwibGluZWFyUGFnZXMiLCJBcnJheSIsImZyb20iLCJsZW5ndGgiLCJfIiwiaSIsImZvckVhY2giLCJwIiwiYWRkIiwibWF4UmFuZG9tIiwibWluUmFuZG9tIiwicmFuZG9tQ291bnQiLCJyYW5kb21QYWdlcyIsIm4iLCJoYXMiLCJsYXN0IiwicHVzaCIsInNpemUiLCJwYWdlcyIsInN0ZXBzIiwicGFnZSIsInRleHQiLCJ0cmFuc2NyaXB0Iiwid29yZHMiLCJzcGxpdCIsImZpbHRlciIsIkJvb2xlYW4iLCJlc3RpbWF0ZWRNcyIsImNlaWwiLCJpbkxpbmVhciIsImluY2x1ZGVzIiwiYXVkaW9VcmwiLCJ0dHNUZXh0IiwibGFiZWwiLCJzcGVha01zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/mockApi.ts\n"));

/***/ })

});