"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/viewer/page",{

/***/ "(app-pages-browser)/./src/lib/agent/useAgentController.ts":
/*!*********************************************!*\
  !*** ./src/lib/agent/useAgentController.ts ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAgentController: function() { return /* binding */ useAgentController; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mockApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mockApi */ \"(app-pages-browser)/./src/lib/agent/mockApi.ts\");\n/* harmony import */ var _lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/audio/useAudioController */ \"(app-pages-browser)/./src/lib/audio/useAudioController.ts\");\n/* __next_internal_client_entry_do_not_use__ useAgentController auto */ \n\n\nfunction useAgentController(pdfRef, baseConfig, opts) {\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        status: \"idle\",\n        currentStepIndex: -1,\n        steps: []\n    });\n    const audio = (0,_lib_audio_useAudioController__WEBPACK_IMPORTED_MODULE_2__.useAudioController)();\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const progressTimer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const progressPausedAt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const progressPauseAccum = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const pendingNav = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [ttsActive, setTtsActive] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const ttsActiveRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const isAdvancingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsTextLenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsBoundarySeenRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const ttsBoundaryFallbackTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const ttsStartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const estimatedTotalMsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const charRateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const ttsTextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n    const ttsWordStartsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const ttsTotalWordsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const userSkipRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const postSlidePromptRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const nextAfterPromptRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pendingNextIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const navigateTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (page)=>{\n        const go = async ()=>{\n            if (opts === null || opts === void 0 ? void 0 : opts.navigate) {\n                opts.navigate(page);\n            } else {\n                const api = pdfRef.current;\n                api === null || api === void 0 ? void 0 : api.goToPage(page);\n            }\n            await new Promise((r)=>setTimeout(r, 150));\n        };\n        const p = go().finally(()=>{\n            if (pendingNav.current === p) pendingNav.current = null;\n        });\n        pendingNav.current = p;\n        await p;\n    }, [\n        opts,\n        pdfRef\n    ]);\n    const stopProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (progressTimer.current) {\n            cancelAnimationFrame(progressTimer.current);\n            progressTimer.current = null;\n        }\n    }, []);\n    const tickProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        const now = performance.now();\n        const paused = progressPausedAt.current;\n        const pauseAdj = progressPauseAccum.current + (paused ? now - paused : 0);\n        const elapsed = now - progressStart.current - pauseAdj;\n        let pct = Math.min(1, elapsed / Math.max(1, progressDuration.current));\n        if (ttsActiveRef.current && pct >= 1) pct = 0.98;\n        setProgress(pct);\n        if (pct < 1 || ttsActiveRef.current) {\n            progressTimer.current = requestAnimationFrame(tickProgress);\n        } else {\n            progressTimer.current = null;\n        }\n    }, []);\n    const startProgress = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((durationMs)=>{\n        stopProgress();\n        setProgress(0);\n        progressDuration.current = Math.max(1000, durationMs);\n        progressStart.current = performance.now();\n        progressPausedAt.current = null;\n        progressPauseAccum.current = 0;\n        progressTimer.current = requestAnimationFrame(tickProgress);\n    }, [\n        stopProgress,\n        tickProgress\n    ]);\n    const cancelSpeech = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const speakText = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((text, fallbackMs)=>{\n        // Clear any prior boundary fallback timer\n        if (ttsBoundaryFallbackTimerRef.current) {\n            window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n            ttsBoundaryFallbackTimerRef.current = null;\n        }\n        ttsBoundarySeenRef.current = false;\n        var _text_length;\n        ttsTextLenRef.current = (_text_length = text === null || text === void 0 ? void 0 : text.length) !== null && _text_length !== void 0 ? _text_length : 0;\n        ttsTextRef.current = text || \"\";\n        // Precompute word starts for boundary-to-word mapping\n        ttsWordStartsRef.current = [];\n        ttsTotalWordsRef.current = 0;\n        if (text) {\n            const regex = /\\b\\w[\\w'\\-]*\\b/g;\n            let m;\n            while((m = regex.exec(text)) !== null){\n                if (typeof m.index === \"number\") {\n                    ttsWordStartsRef.current.push(m.index);\n                }\n            }\n            ttsTotalWordsRef.current = ttsWordStartsRef.current.length;\n        }\n        if (!text) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n        try {\n            const synth = window.speechSynthesis;\n            if (!synth) return ()=>{};\n            if (synth.speaking) synth.cancel();\n            const utter = new SpeechSynthesisUtterance(text);\n            // Keep a consistent rate for predictability\n            utter.rate = 1;\n            utter.onstart = ()=>{\n                setTtsActive(true);\n                ttsActiveRef.current = true;\n                // Clear user-initiated skip suppression once the new step starts speaking\n                userSkipRef.current = false;\n                ttsStartRef.current = performance.now();\n                charRateRef.current = 0;\n                estimatedTotalMsRef.current = fallbackMs || 5000;\n                // Always run a tick; if boundaries show up, it will adapt to time-based estimation\n                startProgress(estimatedTotalMsRef.current);\n            };\n            // Use boundary events to reflect real-time progress\n            utter.onboundary = (ev)=>{\n                ttsBoundarySeenRef.current = true;\n                // Stop timer fallback; boundary will drive progress\n                stopProgress();\n                const idx = typeof (ev === null || ev === void 0 ? void 0 : ev.charIndex) === \"number\" ? ev.charIndex : 0;\n                const starts = ttsWordStartsRef.current;\n                const totalWords = Math.max(1, ttsTotalWordsRef.current);\n                // Count words whose start index is <= current char index\n                let low = 0, high = starts.length;\n                while(low < high){\n                    const mid = low + high >> 1;\n                    if (starts[mid] <= idx) low = mid + 1;\n                    else high = mid;\n                }\n                const spokenWords = Math.min(low, totalWords);\n                let pctWords = spokenWords / totalWords;\n                if (ttsActiveRef.current && pctWords >= 1) pctWords = 0.98;\n                setProgress(pctWords);\n            };\n            utter.onend = ()=>{\n                setTtsActive(false);\n                ttsActiveRef.current = false;\n                // Complete progress and stop timer; auto-advance effect will pick this up\n                stopProgress();\n                setProgress(1);\n            };\n            synth.speak(utter);\n            // If boundary events aren’t supported, start a fallback progress timer after a short delay\n            if (fallbackMs && fallbackMs > 0) {\n                ttsBoundaryFallbackTimerRef.current = window.setTimeout(()=>{\n                    if (!ttsBoundarySeenRef.current) {\n                        startProgress(fallbackMs);\n                    }\n                }, 700);\n            }\n            const cancel = ()=>{\n                try {\n                    synth.cancel();\n                } finally{\n                    setTtsActive(false);\n                    ttsActiveRef.current = false;\n                    if (ttsBoundaryFallbackTimerRef.current) {\n                        window.clearTimeout(ttsBoundaryFallbackTimerRef.current);\n                        ttsBoundaryFallbackTimerRef.current = null;\n                    }\n                }\n            };\n            return cancel;\n        } catch (e) {\n            setTtsActive(false);\n            ttsActiveRef.current = false;\n            return ()=>{};\n        }\n    }, [\n        startProgress,\n        stopProgress\n    ]);\n    const playStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (step)=>{\n        var // Prefer TTS-driven progress via boundaries; fallback to a timer if boundaries aren’t supported\n        _cancelSpeech_current;\n        // Ensure fresh progress/tts state for this step to avoid auto-advance races\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        setState((s)=>({\n                ...s,\n                status: \"navigating\"\n            }));\n        await navigateTo(step.page);\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        var _step_speakMs;\n        cancelSpeech.current = speakText(step.ttsText || step.transcript, (_step_speakMs = step.speakMs) !== null && _step_speakMs !== void 0 ? _step_speakMs : 5000);\n        // Optionally try audio as a subtle background beep if available\n        // but we no longer rely on audio end to advance\n        audio.play(step.audioUrl).catch(()=>{});\n    }, [\n        audio,\n        navigateTo,\n        speakText,\n        stopProgress\n    ]);\n    const start = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (cfg)=>{\n        var _cancelSpeech_current;\n        // Clean up any prior run to ensure fresh state\n        try {\n            audio.stop();\n        } catch (e) {}\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setTtsActive(false);\n        ttsActiveRef.current = false;\n        isAdvancingRef.current = false;\n        pendingNav.current = null;\n        setState((s)=>({\n                ...s,\n                status: \"fetching\",\n                error: undefined\n            }));\n        try {\n            const plan = await (0,_mockApi__WEBPACK_IMPORTED_MODULE_1__.fetchAgentPlan)({\n                ...baseConfig,\n                ...cfg\n            });\n            if (!plan.steps.length) throw new Error(\"No steps returned\");\n            // Initialize and let playStep handle navigation/progress; we only call it once here\n            setState({\n                status: \"navigating\",\n                currentStepIndex: 0,\n                steps: plan.steps\n            });\n            await playStep(plan.steps[0]);\n        } catch (e) {\n            setState((s)=>({\n                    ...s,\n                    status: \"error\",\n                    error: (e === null || e === void 0 ? void 0 : e.message) || \"Unknown error\"\n                }));\n        }\n    }, [\n        audio,\n        baseConfig,\n        playStep,\n        stopProgress\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.pause();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.speaking && !synth.paused) synth.pause();\n        } catch (e) {}\n        // Pause fallback timer progress if running\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current == null) {\n                progressPausedAt.current = performance.now();\n            }\n            if (progressTimer.current) {\n                cancelAnimationFrame(progressTimer.current);\n                progressTimer.current = null;\n            }\n        }\n        setState((s)=>({\n                ...s,\n                status: \"paused\"\n            }));\n    }, [\n        audio\n    ]);\n    const skipTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        var _cancelSpeech_current;\n        const steps = state.steps;\n        if (index < 0 || index >= steps.length) return;\n        // Stop audio and speech and reset progress before switching\n        audio.stop();\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        stopProgress();\n        setProgress(0);\n        setState((s)=>({\n                ...s,\n                currentStepIndex: index\n            }));\n        await playStep(steps[index]);\n    }, [\n        audio,\n        playStep,\n        state.steps,\n        stopProgress\n    ]);\n    const resume = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        audio.resume();\n        try {\n            const synth = window.speechSynthesis;\n            if (synth && synth.paused) synth.resume();\n        } catch (e) {}\n        // Resume fallback timer progress if boundary not available\n        if (!ttsBoundarySeenRef.current) {\n            if (progressPausedAt.current != null) {\n                progressPauseAccum.current += performance.now() - progressPausedAt.current;\n                progressPausedAt.current = null;\n            }\n            if (!progressTimer.current && progress < 1) {\n                progressTimer.current = requestAnimationFrame(tickProgress);\n            }\n        }\n        // If a post-slide prompt was shown, continue to the next step\n        if (nextAfterPromptRef.current && pendingNextIndexRef.current != null) {\n            const idx = pendingNextIndexRef.current;\n            nextAfterPromptRef.current = false;\n            pendingNextIndexRef.current = null;\n            // Switch to next step\n            skipTo(idx);\n            return;\n        }\n        setState((s)=>({\n                ...s,\n                status: \"playing\"\n            }));\n    }, [\n        audio,\n        progress,\n        tickProgress,\n        skipTo\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _cancelSpeech_current;\n        audio.stop();\n        stopProgress();\n        setProgress(0);\n        (_cancelSpeech_current = cancelSpeech.current) === null || _cancelSpeech_current === void 0 ? void 0 : _cancelSpeech_current.call(cancelSpeech);\n        setState({\n            status: \"stopped\",\n            currentStepIndex: -1,\n            steps: []\n        });\n    }, [\n        audio,\n        stopProgress\n    ]);\n    // Public user-initiated jump: prevent auto-advance from chaining over the user’s selection\n    const jumpTo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (index)=>{\n        userSkipRef.current = true;\n        await skipTo(index);\n    }, [\n        skipTo\n    ]);\n    // Auto-advance when progress completes AND TTS (if any) has ended.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        console.log(\"[AutoAdvance] Checking conditions:\", {\n            status: state.status,\n            progress,\n            ttsActive,\n            userSkip: userSkipRef.current,\n            isAdvancing: isAdvancingRef.current\n        });\n        if (state.status !== \"playing\" || progress < 1 || ttsActive) return;\n        // If user just jumped, do not auto-advance from the old step completion\n        if (userSkipRef.current) return;\n        if (isAdvancingRef.current) return;\n        isAdvancingRef.current = true;\n        console.log(\"[AutoAdvance] TRIGGERING - Progress complete and TTS ended\");\n        (async ()=>{\n            // After each slide narration finishes, pause and prompt the user\n            console.log(\"[AutoAdvance] Pausing agent...\");\n            try {\n                pause();\n            } catch (e) {\n                console.error(\"[AutoAdvance] Pause error:\", e);\n            }\n            console.log('[AutoAdvance] Calling postSlidePromptRef.current?.(\"Do you understand?\")');\n            console.log(\"[AutoAdvance] postSlidePromptRef.current exists:\", !!postSlidePromptRef.current);\n            try {\n                var _postSlidePromptRef_current;\n                (_postSlidePromptRef_current = postSlidePromptRef.current) === null || _postSlidePromptRef_current === void 0 ? void 0 : _postSlidePromptRef_current.call(postSlidePromptRef, \"Do you understand?\");\n            } catch (e) {\n                console.error(\"[AutoAdvance] Prompt callback error:\", e);\n            }\n            const next = state.currentStepIndex + 1;\n            console.log(\"[AutoAdvance] Next index:\", next, \"Total steps:\", state.steps.length);\n            if (next < state.steps.length) {\n                nextAfterPromptRef.current = true;\n                pendingNextIndexRef.current = next;\n            } else {\n                // End of plan: behave like Stop for a fresh-ready state\n                stop();\n            }\n        })().finally(()=>{\n            isAdvancingRef.current = false;\n        });\n    }, [\n        progress,\n        ttsActive,\n        state.status,\n        state.currentStepIndex,\n        state.steps.length,\n        pause,\n        stop\n    ]);\n    // Hook up external prompt handler from opts\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        console.log(\"[useAgentController] Setting up postSlidePromptRef with onPrompt callback:\", !!(opts === null || opts === void 0 ? void 0 : opts.onPrompt));\n        var _opts_onPrompt;\n        postSlidePromptRef.current = (_opts_onPrompt = opts === null || opts === void 0 ? void 0 : opts.onPrompt) !== null && _opts_onPrompt !== void 0 ? _opts_onPrompt : null;\n        return ()=>{\n            console.log(\"[useAgentController] Cleaning up postSlidePromptRef\");\n            postSlidePromptRef.current = null;\n        };\n    }, [\n        opts === null || opts === void 0 ? void 0 : opts.onPrompt\n    ]);\n    const currentStep = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        if (state.currentStepIndex < 0) return undefined;\n        return state.steps[state.currentStepIndex];\n    }, [\n        state.currentStepIndex,\n        state.steps\n    ]);\n    const requestPrompt = (message)=>{\n        var _postSlidePromptRef_current;\n        (_postSlidePromptRef_current = postSlidePromptRef.current) === null || _postSlidePromptRef_current === void 0 ? void 0 : _postSlidePromptRef_current.call(postSlidePromptRef, message);\n    };\n    return {\n        state,\n        currentStep,\n        start,\n        pause,\n        resume,\n        stop,\n        skipTo,\n        jumpTo,\n        progress,\n        requestPrompt\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWdlbnQvdXNlQWdlbnRDb250cm9sbGVyLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O3dFQUV5RTtBQUUvQjtBQUV5QjtBQWtCNUQsU0FBU08sbUJBQ2RDLE1BQXVDLEVBQ3ZDQyxVQUE4QixFQUM5QkMsSUFBbUY7SUFFbkYsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdSLCtDQUFRQSxDQUF1QjtRQUN2RFMsUUFBUTtRQUNSQyxrQkFBa0IsQ0FBQztRQUNuQkMsT0FBTyxFQUFFO0lBQ1g7SUFDQSxNQUFNQyxRQUFRVixpRkFBa0JBO0lBQ2hDLE1BQU0sQ0FBQ1csVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNZSxnQkFBZ0JoQiw2Q0FBTUEsQ0FBZ0I7SUFDNUMsTUFBTWlCLGdCQUFnQmpCLDZDQUFNQSxDQUFTO0lBQ3JDLE1BQU1rQixtQkFBbUJsQiw2Q0FBTUEsQ0FBUztJQUN4QyxNQUFNbUIsbUJBQW1CbkIsNkNBQU1BLENBQWdCO0lBQy9DLE1BQU1vQixxQkFBcUJwQiw2Q0FBTUEsQ0FBUztJQUMxQyxNQUFNcUIsYUFBYXJCLDZDQUFNQSxDQUF1QjtJQUNoRCxNQUFNLENBQUNzQixXQUFXQyxhQUFhLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNdUIsZUFBZXhCLDZDQUFNQSxDQUFDO0lBQzVCLE1BQU15QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBQztJQUM5QixNQUFNMEIsZ0JBQWdCMUIsNkNBQU1BLENBQUM7SUFDN0IsTUFBTTJCLHFCQUFxQjNCLDZDQUFNQSxDQUFDO0lBQ2xDLE1BQU00Qiw4QkFBOEI1Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUQsTUFBTTZCLGNBQWM3Qiw2Q0FBTUEsQ0FBZ0I7SUFDMUMsTUFBTThCLHNCQUFzQjlCLDZDQUFNQSxDQUFTO0lBQzNDLE1BQU0rQixjQUFjL0IsNkNBQU1BLENBQVM7SUFDbkMsTUFBTWdDLGFBQWFoQyw2Q0FBTUEsQ0FBUztJQUNsQyxN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QjtRQUFVUTtRQUFXZCxNQUFNRSxNQUFNO1FBQUVGLE1BQU1HLGdCQUFnQjtRQUFFSCxNQUFNSSxLQUFLLENBQUM0RCxNQUFNO1FBQUU2QztRQUFPUDtLQUFLO0lBRS9GLDRDQUE0QztJQUM1Q2hILGdEQUFTQSxDQUFDO1FBQ1IySCxRQUFRQyxHQUFHLENBQUMsOEVBQThFLENBQUMsRUFBQ25ILGlCQUFBQSwyQkFBQUEsS0FBTXVILFFBQVE7WUFDN0V2SDtRQUE3QjZCLG1CQUFtQlEsT0FBTyxHQUFHckMsQ0FBQUEsaUJBQUFBLGlCQUFBQSwyQkFBQUEsS0FBTXVILFFBQVEsY0FBZHZILDRCQUFBQSxpQkFBa0I7UUFDL0MsT0FBTztZQUNMa0gsUUFBUUMsR0FBRyxDQUFDO1lBQ1p0RixtQkFBbUJRLE9BQU8sR0FBRztRQUMvQjtJQUNGLEdBQUc7UUFBQ3JDLGlCQUFBQSwyQkFBQUEsS0FBTXVILFFBQVE7S0FBQztJQUVuQixNQUFNQyxjQUFjaEksOENBQU9BLENBQUM7UUFDMUIsSUFBSVMsTUFBTUcsZ0JBQWdCLEdBQUcsR0FBRyxPQUFPcUc7UUFDdkMsT0FBT3hHLE1BQU1JLEtBQUssQ0FBQ0osTUFBTUcsZ0JBQWdCLENBQUM7SUFDNUMsR0FBRztRQUFDSCxNQUFNRyxnQkFBZ0I7UUFBRUgsTUFBTUksS0FBSztLQUFDO0lBRXhDLE1BQU1vSCxnQkFBZ0IsQ0FBQ1o7WUFDckJoRjtTQUFBQSw4QkFBQUEsbUJBQW1CUSxPQUFPLGNBQTFCUixrREFBQUEsaUNBQUFBLG9CQUE2QmdGO0lBQy9CO0lBRUEsT0FBTztRQUFFNUc7UUFBT3VIO1FBQWFuQjtRQUFPUztRQUFPRTtRQUFRVDtRQUFNUTtRQUFRRTtRQUFRMUc7UUFBVWtIO0lBQWM7QUFDbkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hZ2VudC91c2VBZ2VudENvbnRyb2xsZXIudHM/NGUyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHR5cGUgeyBQZGZDYXJvdXNlbFJlZiB9IGZyb20gJ0AvY29tcG9uZW50cy9QZGZDYXJvdXNlbCdcclxuaW1wb3J0IHsgZmV0Y2hBZ2VudFBsYW4gfSBmcm9tICcuL21vY2tBcGknXHJcbmltcG9ydCB0eXBlIHsgQWdlbnRDb250cm9sbGVyU3RhdGUsIEFnZW50U2Vzc2lvbkNvbmZpZywgQWdlbnRTdGVwIH0gZnJvbSAnLi90eXBlcydcclxuaW1wb3J0IHsgdXNlQXVkaW9Db250cm9sbGVyIH0gZnJvbSAnQC9saWIvYXVkaW8vdXNlQXVkaW9Db250cm9sbGVyJ1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIHN0YXRlOiBBZ2VudENvbnRyb2xsZXJTdGF0ZVxyXG4gIGN1cnJlbnRTdGVwPzogQWdlbnRTdGVwXHJcbiAgc3RhcnQ6IChjZmc/OiBQYXJ0aWFsPEFnZW50U2Vzc2lvbkNvbmZpZz4pID0+IFByb21pc2U8dm9pZD5cclxuICBwYXVzZTogKCkgPT4gdm9pZFxyXG4gIHJlc3VtZTogKCkgPT4gdm9pZFxyXG4gIHN0b3A6ICgpID0+IHZvaWRcclxuICBza2lwVG86IChpbmRleDogbnVtYmVyKSA9PiBQcm9taXNlPHZvaWQ+XHJcbiAgLy8gVXNlci1pbml0aWF0ZWQganVtcCB0aGF0IHN1cHByZXNzZXMgYXV0by1hZHZhbmNlIGR1cmluZyB0cmFuc2l0aW9uXHJcbiAganVtcFRvOiAoaW5kZXg6IG51bWJlcikgPT4gUHJvbWlzZTx2b2lkPlxyXG4gIC8vIFNpbXVsYXRlZCBwcm9ncmVzcyBvZiBjdXJyZW50IHN0ZXA6IDAuLjFcclxuICBwcm9ncmVzczogbnVtYmVyXHJcbiAgLy8gUG9zdC1zbGlkZSBwcm9tcHQgY29udHJvbFxyXG4gIHJlcXVlc3RQcm9tcHQ6IChtZXNzYWdlPzogc3RyaW5nKSA9PiB2b2lkXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBZ2VudENvbnRyb2xsZXIoXHJcbiAgcGRmUmVmOiBSZWFjdC5SZWZPYmplY3Q8UGRmQ2Fyb3VzZWxSZWY+LFxyXG4gIGJhc2VDb25maWc6IEFnZW50U2Vzc2lvbkNvbmZpZyxcclxuICBvcHRzPzogeyBuYXZpZ2F0ZT86IChwYWdlOiBudW1iZXIpID0+IHZvaWQ7IG9uUHJvbXB0PzogKG1lc3NhZ2U/OiBzdHJpbmcpID0+IHZvaWQgfVxyXG4pOiBBZ2VudENvbnRyb2xsZXJBcGkge1xyXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8QWdlbnRDb250cm9sbGVyU3RhdGU+KHtcclxuICAgIHN0YXR1czogJ2lkbGUnLFxyXG4gICAgY3VycmVudFN0ZXBJbmRleDogLTEsXHJcbiAgICBzdGVwczogW10sXHJcbiAgfSlcclxuICBjb25zdCBhdWRpbyA9IHVzZUF1ZGlvQ29udHJvbGxlcigpXHJcbiAgY29uc3QgW3Byb2dyZXNzLCBzZXRQcm9ncmVzc10gPSB1c2VTdGF0ZSgwKVxyXG4gIGNvbnN0IHByb2dyZXNzVGltZXIgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCBwcm9ncmVzc1N0YXJ0ID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc0R1cmF0aW9uID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwcm9ncmVzc1BhdXNlZEF0ID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgcHJvZ3Jlc3NQYXVzZUFjY3VtID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCBwZW5kaW5nTmF2ID0gdXNlUmVmPFByb21pc2U8dm9pZD4gfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IFt0dHNBY3RpdmUsIHNldFR0c0FjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCB0dHNBY3RpdmVSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgaXNBZHZhbmNpbmdSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgdHRzVGV4dExlblJlZiA9IHVzZVJlZigwKVxyXG4gIGNvbnN0IHR0c0JvdW5kYXJ5U2VlblJlZiA9IHVzZVJlZihmYWxzZSlcclxuICBjb25zdCB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuICBjb25zdCB0dHNTdGFydFJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKVxyXG4gIGNvbnN0IGVzdGltYXRlZFRvdGFsTXNSZWYgPSB1c2VSZWY8bnVtYmVyPigwKVxyXG4gIGNvbnN0IGNoYXJSYXRlUmVmID0gdXNlUmVmPG51bWJlcj4oMClcclxuICBjb25zdCB0dHNUZXh0UmVmID0gdXNlUmVmPHN0cmluZz4oJycpXHJcbiAgY29uc3QgdHRzV29yZFN0YXJ0c1JlZiA9IHVzZVJlZjxudW1iZXJbXT4oW10pXHJcbiAgY29uc3QgdHRzVG90YWxXb3Jkc1JlZiA9IHVzZVJlZjxudW1iZXI+KDApXHJcbiAgY29uc3QgdXNlclNraXBSZWYgPSB1c2VSZWYoZmFsc2UpXHJcbiAgY29uc3QgcG9zdFNsaWRlUHJvbXB0UmVmID0gdXNlUmVmPCgobXNnPzogc3RyaW5nKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXHJcbiAgY29uc3QgbmV4dEFmdGVyUHJvbXB0UmVmID0gdXNlUmVmKGZhbHNlKVxyXG4gIGNvbnN0IHBlbmRpbmdOZXh0SW5kZXhSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbClcclxuXHJcbiAgY29uc3QgbmF2aWdhdGVUbyA9IHVzZUNhbGxiYWNrKGFzeW5jIChwYWdlOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IGdvID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgICBpZiAob3B0cz8ubmF2aWdhdGUpIHtcclxuICAgICAgICBvcHRzLm5hdmlnYXRlKHBhZ2UpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgYXBpID0gcGRmUmVmLmN1cnJlbnRcclxuICAgICAgICBhcGk/LmdvVG9QYWdlKHBhZ2UpXHJcbiAgICAgIH1cclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgMTUwKSlcclxuICAgIH1cclxuICAgIGNvbnN0IHAgPSBnbygpLmZpbmFsbHkoKCkgPT4ge1xyXG4gICAgICBpZiAocGVuZGluZ05hdi5jdXJyZW50ID09PSBwKSBwZW5kaW5nTmF2LmN1cnJlbnQgPSBudWxsXHJcbiAgICB9KVxyXG4gICAgcGVuZGluZ05hdi5jdXJyZW50ID0gcFxyXG4gICAgYXdhaXQgcFxyXG4gIH0sIFtvcHRzLCBwZGZSZWZdKVxyXG5cclxuICBjb25zdCBzdG9wUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBpZiAocHJvZ3Jlc3NUaW1lci5jdXJyZW50KSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXIuY3VycmVudClcclxuICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gIH0sIFtdKVxyXG5cclxuICBjb25zdCB0aWNrUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCBub3cgPSBwZXJmb3JtYW5jZS5ub3coKVxyXG4gICAgY29uc3QgcGF1c2VkID0gcHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50XHJcbiAgICBjb25zdCBwYXVzZUFkaiA9IHByb2dyZXNzUGF1c2VBY2N1bS5jdXJyZW50ICsgKHBhdXNlZCA/IG5vdyAtIHBhdXNlZCA6IDApXHJcbiAgICBjb25zdCBlbGFwc2VkID0gbm93IC0gcHJvZ3Jlc3NTdGFydC5jdXJyZW50IC0gcGF1c2VBZGpcclxuICAgIGxldCBwY3QgPSBNYXRoLm1pbigxLCBlbGFwc2VkIC8gTWF0aC5tYXgoMSwgcHJvZ3Jlc3NEdXJhdGlvbi5jdXJyZW50KSlcclxuICAgIGlmICh0dHNBY3RpdmVSZWYuY3VycmVudCAmJiBwY3QgPj0gMSkgcGN0ID0gMC45OFxyXG4gICAgc2V0UHJvZ3Jlc3MocGN0KVxyXG4gICAgaWYgKHBjdCA8IDEgfHwgdHRzQWN0aXZlUmVmLmN1cnJlbnQpIHtcclxuICAgICAgcHJvZ3Jlc3NUaW1lci5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2tQcm9ncmVzcylcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IG51bGxcclxuICAgIH1cclxuICB9LCBbXSlcclxuXHJcbiAgY29uc3Qgc3RhcnRQcm9ncmVzcyA9IHVzZUNhbGxiYWNrKChkdXJhdGlvbk1zOiBudW1iZXIpID0+IHtcclxuICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgcHJvZ3Jlc3NEdXJhdGlvbi5jdXJyZW50ID0gTWF0aC5tYXgoMTAwMCwgZHVyYXRpb25NcylcclxuICAgIHByb2dyZXNzU3RhcnQuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpXHJcbiAgICBwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPSBudWxsXHJcbiAgICBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCA9IDBcclxuICAgIHByb2dyZXNzVGltZXIuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrUHJvZ3Jlc3MpXHJcbiAgfSwgW3N0b3BQcm9ncmVzcywgdGlja1Byb2dyZXNzXSlcclxuXHJcbiAgY29uc3QgY2FuY2VsU3BlZWNoID0gdXNlUmVmPCgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpXHJcblxyXG4gIGNvbnN0IHNwZWFrVGV4dCA9IHVzZUNhbGxiYWNrKCh0ZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQsIGZhbGxiYWNrTXM/OiBudW1iZXIpID0+IHtcclxuICAgIC8vIENsZWFyIGFueSBwcmlvciBib3VuZGFyeSBmYWxsYmFjayB0aW1lclxyXG4gICAgaWYgKHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KSB7XHJcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodHRzQm91bmRhcnlGYWxsYmFja1RpbWVyUmVmLmN1cnJlbnQpXHJcbiAgICAgIHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50ID0gbnVsbFxyXG4gICAgfVxyXG4gICAgdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgdHRzVGV4dExlblJlZi5jdXJyZW50ID0gdGV4dD8ubGVuZ3RoID8/IDBcclxuICAgIHR0c1RleHRSZWYuY3VycmVudCA9IHRleHQgfHwgJydcclxuICAgIC8vIFByZWNvbXB1dGUgd29yZCBzdGFydHMgZm9yIGJvdW5kYXJ5LXRvLXdvcmQgbWFwcGluZ1xyXG4gICAgdHRzV29yZFN0YXJ0c1JlZi5jdXJyZW50ID0gW11cclxuICAgIHR0c1RvdGFsV29yZHNSZWYuY3VycmVudCA9IDBcclxuICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgIGNvbnN0IHJlZ2V4ID0gL1xcYlxcd1tcXHcnXFwtXSpcXGIvZ1xyXG4gICAgICBsZXQgbTogUmVnRXhwRXhlY0FycmF5IHwgbnVsbFxyXG4gICAgICB3aGlsZSAoKG0gPSByZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbS5pbmRleCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgIHR0c1dvcmRTdGFydHNSZWYuY3VycmVudC5wdXNoKG0uaW5kZXgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHR0c1RvdGFsV29yZHNSZWYuY3VycmVudCA9IHR0c1dvcmRTdGFydHNSZWYuY3VycmVudC5sZW5ndGhcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRleHQpIHtcclxuICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICB0dHNBY3RpdmVSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHJldHVybiAoKSA9PiB7fVxyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3ludGggPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzXHJcbiAgICAgIGlmICghc3ludGgpIHJldHVybiAoKSA9PiB7fVxyXG4gICAgICBpZiAoc3ludGguc3BlYWtpbmcpIHN5bnRoLmNhbmNlbCgpXHJcbiAgICAgIGNvbnN0IHV0dGVyID0gbmV3IFNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSh0ZXh0KVxyXG4gICAgICAvLyBLZWVwIGEgY29uc2lzdGVudCByYXRlIGZvciBwcmVkaWN0YWJpbGl0eVxyXG4gICAgICB1dHRlci5yYXRlID0gMVxyXG4gICAgICB1dHRlci5vbnN0YXJ0ID0gKCkgPT4ge1xyXG4gICAgICAgIHNldFR0c0FjdGl2ZSh0cnVlKVxyXG4gICAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZVxyXG4gICAgICAgIC8vIENsZWFyIHVzZXItaW5pdGlhdGVkIHNraXAgc3VwcHJlc3Npb24gb25jZSB0aGUgbmV3IHN0ZXAgc3RhcnRzIHNwZWFraW5nXHJcbiAgICAgICAgdXNlclNraXBSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgICAgdHRzU3RhcnRSZWYuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpXHJcbiAgICAgICAgY2hhclJhdGVSZWYuY3VycmVudCA9IDBcclxuICAgICAgICBlc3RpbWF0ZWRUb3RhbE1zUmVmLmN1cnJlbnQgPSBmYWxsYmFja01zIHx8IDUwMDBcclxuICAgICAgICAvLyBBbHdheXMgcnVuIGEgdGljazsgaWYgYm91bmRhcmllcyBzaG93IHVwLCBpdCB3aWxsIGFkYXB0IHRvIHRpbWUtYmFzZWQgZXN0aW1hdGlvblxyXG4gICAgICAgIHN0YXJ0UHJvZ3Jlc3MoZXN0aW1hdGVkVG90YWxNc1JlZi5jdXJyZW50KVxyXG4gICAgICB9XHJcbiAgICAgIC8vIFVzZSBib3VuZGFyeSBldmVudHMgdG8gcmVmbGVjdCByZWFsLXRpbWUgcHJvZ3Jlc3NcclxuICAgICAgdXR0ZXIub25ib3VuZGFyeSA9IChldjogYW55KSA9PiB7XHJcbiAgICAgICAgdHRzQm91bmRhcnlTZWVuUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgLy8gU3RvcCB0aW1lciBmYWxsYmFjazsgYm91bmRhcnkgd2lsbCBkcml2ZSBwcm9ncmVzc1xyXG4gICAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgICAgY29uc3QgaWR4OiBudW1iZXIgPSB0eXBlb2YgZXY/LmNoYXJJbmRleCA9PT0gJ251bWJlcicgPyBldi5jaGFySW5kZXggOiAwXHJcbiAgICAgICAgY29uc3Qgc3RhcnRzID0gdHRzV29yZFN0YXJ0c1JlZi5jdXJyZW50XHJcbiAgICAgICAgY29uc3QgdG90YWxXb3JkcyA9IE1hdGgubWF4KDEsIHR0c1RvdGFsV29yZHNSZWYuY3VycmVudClcclxuICAgICAgICAvLyBDb3VudCB3b3JkcyB3aG9zZSBzdGFydCBpbmRleCBpcyA8PSBjdXJyZW50IGNoYXIgaW5kZXhcclxuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IHN0YXJ0cy5sZW5ndGhcclxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xyXG4gICAgICAgICAgY29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+IDFcclxuICAgICAgICAgIGlmIChzdGFydHNbbWlkXSA8PSBpZHgpIGxvdyA9IG1pZCArIDFcclxuICAgICAgICAgIGVsc2UgaGlnaCA9IG1pZFxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcG9rZW5Xb3JkcyA9IE1hdGgubWluKGxvdywgdG90YWxXb3JkcylcclxuICAgICAgICBsZXQgcGN0V29yZHMgPSBzcG9rZW5Xb3JkcyAvIHRvdGFsV29yZHNcclxuICAgICAgICBpZiAodHRzQWN0aXZlUmVmLmN1cnJlbnQgJiYgcGN0V29yZHMgPj0gMSkgcGN0V29yZHMgPSAwLjk4XHJcbiAgICAgICAgc2V0UHJvZ3Jlc3MocGN0V29yZHMpXHJcbiAgICAgIH1cclxuICAgICAgdXR0ZXIub25lbmQgPSAoKSA9PiB7XHJcbiAgICAgICAgc2V0VHRzQWN0aXZlKGZhbHNlKVxyXG4gICAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAvLyBDb21wbGV0ZSBwcm9ncmVzcyBhbmQgc3RvcCB0aW1lcjsgYXV0by1hZHZhbmNlIGVmZmVjdCB3aWxsIHBpY2sgdGhpcyB1cFxyXG4gICAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgICAgc2V0UHJvZ3Jlc3MoMSlcclxuICAgICAgfVxyXG4gICAgICBzeW50aC5zcGVhayh1dHRlcilcclxuXHJcbiAgICAgIC8vIElmIGJvdW5kYXJ5IGV2ZW50cyBhcmVu4oCZdCBzdXBwb3J0ZWQsIHN0YXJ0IGEgZmFsbGJhY2sgcHJvZ3Jlc3MgdGltZXIgYWZ0ZXIgYSBzaG9ydCBkZWxheVxyXG4gICAgICBpZiAoZmFsbGJhY2tNcyAmJiBmYWxsYmFja01zID4gMCkge1xyXG4gICAgICAgIHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgaWYgKCF0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBzdGFydFByb2dyZXNzKGZhbGxiYWNrTXMpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwgNzAwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHN5bnRoLmNhbmNlbCgpXHJcbiAgICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgICAgIGlmICh0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHR0c0JvdW5kYXJ5RmFsbGJhY2tUaW1lclJlZi5jdXJyZW50KVxyXG4gICAgICAgICAgICB0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNhbmNlbFxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICByZXR1cm4gKCkgPT4ge31cclxuICAgIH1cclxuICB9LCBbc3RhcnRQcm9ncmVzcywgc3RvcFByb2dyZXNzXSlcclxuXHJcbiAgY29uc3QgcGxheVN0ZXAgPSB1c2VDYWxsYmFjayhcclxuICAgIGFzeW5jIChzdGVwOiBBZ2VudFN0ZXApID0+IHtcclxuICAgICAgLy8gRW5zdXJlIGZyZXNoIHByb2dyZXNzL3R0cyBzdGF0ZSBmb3IgdGhpcyBzdGVwIHRvIGF2b2lkIGF1dG8tYWR2YW5jZSByYWNlc1xyXG4gICAgICBzdG9wUHJvZ3Jlc3MoKVxyXG4gICAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgICBzZXRUdHNBY3RpdmUoZmFsc2UpXHJcbiAgICAgIHR0c0FjdGl2ZVJlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ25hdmlnYXRpbmcnIH0pKVxyXG4gICAgICBhd2FpdCBuYXZpZ2F0ZVRvKHN0ZXAucGFnZSlcclxuICAgICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ3BsYXlpbmcnIH0pKVxyXG4gICAgICAvLyBQcmVmZXIgVFRTLWRyaXZlbiBwcm9ncmVzcyB2aWEgYm91bmRhcmllczsgZmFsbGJhY2sgdG8gYSB0aW1lciBpZiBib3VuZGFyaWVzIGFyZW7igJl0IHN1cHBvcnRlZFxyXG4gICAgICBjYW5jZWxTcGVlY2guY3VycmVudD8uKClcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQgPSBzcGVha1RleHQoc3RlcC50dHNUZXh0IHx8IHN0ZXAudHJhbnNjcmlwdCwgc3RlcC5zcGVha01zID8/IDUwMDApXHJcbiAgICAgIC8vIE9wdGlvbmFsbHkgdHJ5IGF1ZGlvIGFzIGEgc3VidGxlIGJhY2tncm91bmQgYmVlcCBpZiBhdmFpbGFibGVcclxuICAgICAgLy8gYnV0IHdlIG5vIGxvbmdlciByZWx5IG9uIGF1ZGlvIGVuZCB0byBhZHZhbmNlXHJcbiAgICAgIGF1ZGlvLnBsYXkoc3RlcC5hdWRpb1VybCkuY2F0Y2goKCkgPT4ge30pXHJcbiAgICB9LFxyXG4gICAgW2F1ZGlvLCBuYXZpZ2F0ZVRvLCBzcGVha1RleHQsIHN0b3BQcm9ncmVzc11cclxuICApXHJcblxyXG4gIGNvbnN0IHN0YXJ0ID0gdXNlQ2FsbGJhY2soXHJcbiAgICBhc3luYyAoY2ZnPzogUGFydGlhbDxBZ2VudFNlc3Npb25Db25maWc+KSA9PiB7XHJcbiAgICAgIC8vIENsZWFuIHVwIGFueSBwcmlvciBydW4gdG8gZW5zdXJlIGZyZXNoIHN0YXRlXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgYXVkaW8uc3RvcCgpXHJcbiAgICAgIH0gY2F0Y2gge31cclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgIHNldFByb2dyZXNzKDApXHJcbiAgICAgIHNldFR0c0FjdGl2ZShmYWxzZSlcclxuICAgICAgdHRzQWN0aXZlUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgICBpc0FkdmFuY2luZ1JlZi5jdXJyZW50ID0gZmFsc2VcclxuICAgICAgcGVuZGluZ05hdi5jdXJyZW50ID0gbnVsbFxyXG5cclxuICAgICAgc2V0U3RhdGUoKHMpID0+ICh7IC4uLnMsIHN0YXR1czogJ2ZldGNoaW5nJywgZXJyb3I6IHVuZGVmaW5lZCB9KSlcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBwbGFuID0gYXdhaXQgZmV0Y2hBZ2VudFBsYW4oeyAuLi5iYXNlQ29uZmlnLCAuLi5jZmcgfSlcclxuICAgICAgICBpZiAoIXBsYW4uc3RlcHMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHN0ZXBzIHJldHVybmVkJylcclxuICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBsZXQgcGxheVN0ZXAgaGFuZGxlIG5hdmlnYXRpb24vcHJvZ3Jlc3M7IHdlIG9ubHkgY2FsbCBpdCBvbmNlIGhlcmVcclxuICAgICAgICBzZXRTdGF0ZSh7IHN0YXR1czogJ25hdmlnYXRpbmcnLCBjdXJyZW50U3RlcEluZGV4OiAwLCBzdGVwczogcGxhbi5zdGVwcyB9KVxyXG4gICAgICAgIGF3YWl0IHBsYXlTdGVwKHBsYW4uc3RlcHNbMF0pXHJcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xyXG4gICAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdlcnJvcicsIGVycm9yOiBlPy5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJyB9KSlcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgYmFzZUNvbmZpZywgcGxheVN0ZXAsIHN0b3BQcm9ncmVzc11cclxuICApXHJcblxyXG4gIGNvbnN0IHBhdXNlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgYXVkaW8ucGF1c2UoKVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3ludGggPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzXHJcbiAgICAgIGlmIChzeW50aCAmJiBzeW50aC5zcGVha2luZyAmJiAhc3ludGgucGF1c2VkKSBzeW50aC5wYXVzZSgpXHJcbiAgICB9IGNhdGNoIHt9XHJcbiAgICAvLyBQYXVzZSBmYWxsYmFjayB0aW1lciBwcm9ncmVzcyBpZiBydW5uaW5nXHJcbiAgICBpZiAoIXR0c0JvdW5kYXJ5U2VlblJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGlmIChwcm9ncmVzc1BhdXNlZEF0LmN1cnJlbnQgPT0gbnVsbCkge1xyXG4gICAgICAgIHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpXHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb2dyZXNzVGltZXIuY3VycmVudCkge1xyXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHByb2dyZXNzVGltZXIuY3VycmVudClcclxuICAgICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwYXVzZWQnIH0pKVxyXG4gIH0sIFthdWRpb10pXHJcblxyXG4gIGNvbnN0IHNraXBUbyA9IHVzZUNhbGxiYWNrKFxyXG4gICAgYXN5bmMgKGluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgY29uc3Qgc3RlcHMgPSBzdGF0ZS5zdGVwc1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHN0ZXBzLmxlbmd0aCkgcmV0dXJuXHJcbiAgICAgIC8vIFN0b3AgYXVkaW8gYW5kIHNwZWVjaCBhbmQgcmVzZXQgcHJvZ3Jlc3MgYmVmb3JlIHN3aXRjaGluZ1xyXG4gICAgICBhdWRpby5zdG9wKClcclxuICAgICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICAgIHNldFByb2dyZXNzKDApXHJcbiAgICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBjdXJyZW50U3RlcEluZGV4OiBpbmRleCB9KSlcclxuICAgICAgYXdhaXQgcGxheVN0ZXAoc3RlcHNbaW5kZXhdKVxyXG4gICAgfSxcclxuICAgIFthdWRpbywgcGxheVN0ZXAsIHN0YXRlLnN0ZXBzLCBzdG9wUHJvZ3Jlc3NdXHJcbiAgKVxyXG5cclxuICBjb25zdCByZXN1bWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBhdWRpby5yZXN1bWUoKVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3ludGggPSB3aW5kb3cuc3BlZWNoU3ludGhlc2lzXHJcbiAgICAgIGlmIChzeW50aCAmJiBzeW50aC5wYXVzZWQpIHN5bnRoLnJlc3VtZSgpXHJcbiAgICB9IGNhdGNoIHt9XHJcbiAgICAvLyBSZXN1bWUgZmFsbGJhY2sgdGltZXIgcHJvZ3Jlc3MgaWYgYm91bmRhcnkgbm90IGF2YWlsYWJsZVxyXG4gICAgaWYgKCF0dHNCb3VuZGFyeVNlZW5SZWYuY3VycmVudCkge1xyXG4gICAgICBpZiAocHJvZ3Jlc3NQYXVzZWRBdC5jdXJyZW50ICE9IG51bGwpIHtcclxuICAgICAgICBwcm9ncmVzc1BhdXNlQWNjdW0uY3VycmVudCArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2dyZXNzUGF1c2VkQXQuY3VycmVudFxyXG4gICAgICAgIHByb2dyZXNzUGF1c2VkQXQuY3VycmVudCA9IG51bGxcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXByb2dyZXNzVGltZXIuY3VycmVudCAmJiBwcm9ncmVzcyA8IDEpIHtcclxuICAgICAgICBwcm9ncmVzc1RpbWVyLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGlja1Byb2dyZXNzKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJZiBhIHBvc3Qtc2xpZGUgcHJvbXB0IHdhcyBzaG93biwgY29udGludWUgdG8gdGhlIG5leHQgc3RlcFxyXG4gICAgaWYgKG5leHRBZnRlclByb21wdFJlZi5jdXJyZW50ICYmIHBlbmRpbmdOZXh0SW5kZXhSZWYuY3VycmVudCAhPSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IGlkeCA9IHBlbmRpbmdOZXh0SW5kZXhSZWYuY3VycmVudFxyXG4gICAgICBuZXh0QWZ0ZXJQcm9tcHRSZWYuY3VycmVudCA9IGZhbHNlXHJcbiAgICAgIHBlbmRpbmdOZXh0SW5kZXhSZWYuY3VycmVudCA9IG51bGxcclxuICAgICAgLy8gU3dpdGNoIHRvIG5leHQgc3RlcFxyXG4gICAgICBza2lwVG8oaWR4KVxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIHNldFN0YXRlKChzKSA9PiAoeyAuLi5zLCBzdGF0dXM6ICdwbGF5aW5nJyB9KSlcclxuICB9LCBbYXVkaW8sIHByb2dyZXNzLCB0aWNrUHJvZ3Jlc3MsIHNraXBUb10pXHJcblxyXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBhdWRpby5zdG9wKClcclxuICAgIHN0b3BQcm9ncmVzcygpXHJcbiAgICBzZXRQcm9ncmVzcygwKVxyXG4gICAgY2FuY2VsU3BlZWNoLmN1cnJlbnQ/LigpXHJcbiAgICBzZXRTdGF0ZSh7IHN0YXR1czogJ3N0b3BwZWQnLCBjdXJyZW50U3RlcEluZGV4OiAtMSwgc3RlcHM6IFtdIH0pXHJcbiAgfSwgW2F1ZGlvLCBzdG9wUHJvZ3Jlc3NdKVxyXG5cclxuICAvLyBQdWJsaWMgdXNlci1pbml0aWF0ZWQganVtcDogcHJldmVudCBhdXRvLWFkdmFuY2UgZnJvbSBjaGFpbmluZyBvdmVyIHRoZSB1c2Vy4oCZcyBzZWxlY3Rpb25cclxuICBjb25zdCBqdW1wVG8gPSB1c2VDYWxsYmFjayhhc3luYyAoaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgdXNlclNraXBSZWYuY3VycmVudCA9IHRydWVcclxuICAgIGF3YWl0IHNraXBUbyhpbmRleClcclxuICB9LCBbc2tpcFRvXSlcclxuXHJcbiAgLy8gQXV0by1hZHZhbmNlIHdoZW4gcHJvZ3Jlc3MgY29tcGxldGVzIEFORCBUVFMgKGlmIGFueSkgaGFzIGVuZGVkLlxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnW0F1dG9BZHZhbmNlXSBDaGVja2luZyBjb25kaXRpb25zOicsIHtcclxuICAgICAgc3RhdHVzOiBzdGF0ZS5zdGF0dXMsXHJcbiAgICAgIHByb2dyZXNzLFxyXG4gICAgICB0dHNBY3RpdmUsXHJcbiAgICAgIHVzZXJTa2lwOiB1c2VyU2tpcFJlZi5jdXJyZW50LFxyXG4gICAgICBpc0FkdmFuY2luZzogaXNBZHZhbmNpbmdSZWYuY3VycmVudCxcclxuICAgIH0pXHJcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSAncGxheWluZycgfHwgcHJvZ3Jlc3MgPCAxIHx8IHR0c0FjdGl2ZSkgcmV0dXJuXHJcbiAgICAvLyBJZiB1c2VyIGp1c3QganVtcGVkLCBkbyBub3QgYXV0by1hZHZhbmNlIGZyb20gdGhlIG9sZCBzdGVwIGNvbXBsZXRpb25cclxuICAgIGlmICh1c2VyU2tpcFJlZi5jdXJyZW50KSByZXR1cm5cclxuICAgIGlmIChpc0FkdmFuY2luZ1JlZi5jdXJyZW50KSByZXR1cm5cclxuICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICBjb25zb2xlLmxvZygnW0F1dG9BZHZhbmNlXSBUUklHR0VSSU5HIC0gUHJvZ3Jlc3MgY29tcGxldGUgYW5kIFRUUyBlbmRlZCcpXHJcbiAgICA7KGFzeW5jICgpID0+IHtcclxuICAgICAgLy8gQWZ0ZXIgZWFjaCBzbGlkZSBuYXJyYXRpb24gZmluaXNoZXMsIHBhdXNlIGFuZCBwcm9tcHQgdGhlIHVzZXJcclxuICAgICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gUGF1c2luZyBhZ2VudC4uLicpXHJcbiAgICAgIHRyeSB7IHBhdXNlKCkgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmVycm9yKCdbQXV0b0FkdmFuY2VdIFBhdXNlIGVycm9yOicsIGUpIH1cclxuICAgICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gQ2FsbGluZyBwb3N0U2xpZGVQcm9tcHRSZWYuY3VycmVudD8uKFwiRG8geW91IHVuZGVyc3RhbmQ/XCIpJylcclxuICAgICAgY29uc29sZS5sb2coJ1tBdXRvQWR2YW5jZV0gcG9zdFNsaWRlUHJvbXB0UmVmLmN1cnJlbnQgZXhpc3RzOicsICEhcG9zdFNsaWRlUHJvbXB0UmVmLmN1cnJlbnQpXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcG9zdFNsaWRlUHJvbXB0UmVmLmN1cnJlbnQ/LignRG8geW91IHVuZGVyc3RhbmQ/JylcclxuICAgICAgfSBjYXRjaCAoZSkgeyBjb25zb2xlLmVycm9yKCdbQXV0b0FkdmFuY2VdIFByb21wdCBjYWxsYmFjayBlcnJvcjonLCBlKSB9XHJcbiAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5jdXJyZW50U3RlcEluZGV4ICsgMVxyXG4gICAgICBjb25zb2xlLmxvZygnW0F1dG9BZHZhbmNlXSBOZXh0IGluZGV4OicsIG5leHQsICdUb3RhbCBzdGVwczonLCBzdGF0ZS5zdGVwcy5sZW5ndGgpXHJcbiAgICAgIGlmIChuZXh0IDwgc3RhdGUuc3RlcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgbmV4dEFmdGVyUHJvbXB0UmVmLmN1cnJlbnQgPSB0cnVlXHJcbiAgICAgICAgcGVuZGluZ05leHRJbmRleFJlZi5jdXJyZW50ID0gbmV4dFxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEVuZCBvZiBwbGFuOiBiZWhhdmUgbGlrZSBTdG9wIGZvciBhIGZyZXNoLXJlYWR5IHN0YXRlXHJcbiAgICAgICAgc3RvcCgpXHJcbiAgICAgIH1cclxuICAgIH0pKCkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgIGlzQWR2YW5jaW5nUmVmLmN1cnJlbnQgPSBmYWxzZVxyXG4gICAgfSlcclxuICB9LCBbcHJvZ3Jlc3MsIHR0c0FjdGl2ZSwgc3RhdGUuc3RhdHVzLCBzdGF0ZS5jdXJyZW50U3RlcEluZGV4LCBzdGF0ZS5zdGVwcy5sZW5ndGgsIHBhdXNlLCBzdG9wXSlcclxuXHJcbiAgLy8gSG9vayB1cCBleHRlcm5hbCBwcm9tcHQgaGFuZGxlciBmcm9tIG9wdHNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc29sZS5sb2coJ1t1c2VBZ2VudENvbnRyb2xsZXJdIFNldHRpbmcgdXAgcG9zdFNsaWRlUHJvbXB0UmVmIHdpdGggb25Qcm9tcHQgY2FsbGJhY2s6JywgISFvcHRzPy5vblByb21wdClcclxuICAgIHBvc3RTbGlkZVByb21wdFJlZi5jdXJyZW50ID0gb3B0cz8ub25Qcm9tcHQgPz8gbnVsbFxyXG4gICAgcmV0dXJuICgpID0+IHsgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdbdXNlQWdlbnRDb250cm9sbGVyXSBDbGVhbmluZyB1cCBwb3N0U2xpZGVQcm9tcHRSZWYnKVxyXG4gICAgICBwb3N0U2xpZGVQcm9tcHRSZWYuY3VycmVudCA9IG51bGwgXHJcbiAgICB9XHJcbiAgfSwgW29wdHM/Lm9uUHJvbXB0XSlcclxuXHJcbiAgY29uc3QgY3VycmVudFN0ZXAgPSB1c2VNZW1vKCgpID0+IHtcclxuICAgIGlmIChzdGF0ZS5jdXJyZW50U3RlcEluZGV4IDwgMCkgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgcmV0dXJuIHN0YXRlLnN0ZXBzW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXhdXHJcbiAgfSwgW3N0YXRlLmN1cnJlbnRTdGVwSW5kZXgsIHN0YXRlLnN0ZXBzXSlcclxuXHJcbiAgY29uc3QgcmVxdWVzdFByb21wdCA9IChtZXNzYWdlPzogc3RyaW5nKSA9PiB7XHJcbiAgICBwb3N0U2xpZGVQcm9tcHRSZWYuY3VycmVudD8uKG1lc3NhZ2UpXHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBzdGF0ZSwgY3VycmVudFN0ZXAsIHN0YXJ0LCBwYXVzZSwgcmVzdW1lLCBzdG9wLCBza2lwVG8sIGp1bXBUbywgcHJvZ3Jlc3MsIHJlcXVlc3RQcm9tcHQgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImZldGNoQWdlbnRQbGFuIiwidXNlQXVkaW9Db250cm9sbGVyIiwidXNlQWdlbnRDb250cm9sbGVyIiwicGRmUmVmIiwiYmFzZUNvbmZpZyIsIm9wdHMiLCJzdGF0ZSIsInNldFN0YXRlIiwic3RhdHVzIiwiY3VycmVudFN0ZXBJbmRleCIsInN0ZXBzIiwiYXVkaW8iLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwicHJvZ3Jlc3NUaW1lciIsInByb2dyZXNzU3RhcnQiLCJwcm9ncmVzc0R1cmF0aW9uIiwicHJvZ3Jlc3NQYXVzZWRBdCIsInByb2dyZXNzUGF1c2VBY2N1bSIsInBlbmRpbmdOYXYiLCJ0dHNBY3RpdmUiLCJzZXRUdHNBY3RpdmUiLCJ0dHNBY3RpdmVSZWYiLCJpc0FkdmFuY2luZ1JlZiIsInR0c1RleHRMZW5SZWYiLCJ0dHNCb3VuZGFyeVNlZW5SZWYiLCJ0dHNCb3VuZGFyeUZhbGxiYWNrVGltZXJSZWYiLCJ0dHNTdGFydFJlZiIsImVzdGltYXRlZFRvdGFsTXNSZWYiLCJjaGFyUmF0ZVJlZiIsInR0c1RleHRSZWYiLCJ0dHNXb3JkU3RhcnRzUmVmIiwidHRzVG90YWxXb3Jkc1JlZiIsInVzZXJTa2lwUmVmIiwicG9zdFNsaWRlUHJvbXB0UmVmIiwibmV4dEFmdGVyUHJvbXB0UmVmIiwicGVuZGluZ05leHRJbmRleFJlZiIsIm5hdmlnYXRlVG8iLCJwYWdlIiwiZ28iLCJuYXZpZ2F0ZSIsImFwaSIsImN1cnJlbnQiLCJnb1RvUGFnZSIsIlByb21pc2UiLCJyIiwic2V0VGltZW91dCIsInAiLCJmaW5hbGx5Iiwic3RvcFByb2dyZXNzIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ0aWNrUHJvZ3Jlc3MiLCJub3ciLCJwZXJmb3JtYW5jZSIsInBhdXNlZCIsInBhdXNlQWRqIiwiZWxhcHNlZCIsInBjdCIsIk1hdGgiLCJtaW4iLCJtYXgiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJzdGFydFByb2dyZXNzIiwiZHVyYXRpb25NcyIsImNhbmNlbFNwZWVjaCIsInNwZWFrVGV4dCIsInRleHQiLCJmYWxsYmFja01zIiwid2luZG93IiwiY2xlYXJUaW1lb3V0IiwibGVuZ3RoIiwicmVnZXgiLCJtIiwiZXhlYyIsImluZGV4IiwicHVzaCIsInN5bnRoIiwic3BlZWNoU3ludGhlc2lzIiwic3BlYWtpbmciLCJjYW5jZWwiLCJ1dHRlciIsIlNwZWVjaFN5bnRoZXNpc1V0dGVyYW5jZSIsInJhdGUiLCJvbnN0YXJ0Iiwib25ib3VuZGFyeSIsImV2IiwiaWR4IiwiY2hhckluZGV4Iiwic3RhcnRzIiwidG90YWxXb3JkcyIsImxvdyIsImhpZ2giLCJtaWQiLCJzcG9rZW5Xb3JkcyIsInBjdFdvcmRzIiwib25lbmQiLCJzcGVhayIsInBsYXlTdGVwIiwic3RlcCIsInMiLCJ0dHNUZXh0IiwidHJhbnNjcmlwdCIsInNwZWFrTXMiLCJwbGF5IiwiYXVkaW9VcmwiLCJjYXRjaCIsInN0YXJ0IiwiY2ZnIiwic3RvcCIsImVycm9yIiwidW5kZWZpbmVkIiwicGxhbiIsIkVycm9yIiwiZSIsIm1lc3NhZ2UiLCJwYXVzZSIsInNraXBUbyIsInJlc3VtZSIsImp1bXBUbyIsImNvbnNvbGUiLCJsb2ciLCJ1c2VyU2tpcCIsImlzQWR2YW5jaW5nIiwibmV4dCIsIm9uUHJvbXB0IiwiY3VycmVudFN0ZXAiLCJyZXF1ZXN0UHJvbXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/agent/useAgentController.ts\n"));

/***/ })

});